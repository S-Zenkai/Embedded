; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\stm32f10x_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\output\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Drivers\CMSIS -I..\Drivers\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\Drivers\BSP\SYS -I..\Drivers\BSP\SYSTICK -I..\Drivers\BSP\USART -I..\Middlewares\FreeRTOS\include -I..\Middlewares\FreeRTOS\portable\RVDS\ARM_CM3 -I..\Drivers\BSP\LED -I..\Drivers\BSP\OLED -I..\Drivers\BSP\TIM -I..\Drivers\BSP\PWM -I..\Drivers\BSP\SYSTICK -I..\Drivers\BSP\SYS -ID:\AppData\keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=540 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\output\stm32f10x_i2c.crf ..\Drivers\STM32F10x_StdPeriph_Driver\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;838      */
;;;839    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L1.12|
;;;840    {
;;;841      /* Check the parameters */
;;;842      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;843      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;844      if (NewState != DISABLE)
;;;845      {
;;;846        /* Enable the selected I2C ARP */
;;;847        I2Cx->CR1 |= CR1_ENARP_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420210          ORR      r2,r2,#0x10
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L1.22|
                  |L1.12|
;;;848      }
;;;849      else
;;;850      {
;;;851        /* Disable the selected I2C ARP */
;;;852        I2Cx->CR1 &= CR1_ENARP_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73ef          MOV      r3,#0xffef
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L1.22|
;;;853      }
;;;854    }
000016  4770              BX       lr
;;;855    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;440      */
;;;441    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L2.12|
;;;442    {
;;;443      /* Check the parameters */
;;;444      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;445      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;446      if (NewState != DISABLE)
;;;447      {
;;;448        /* Enable the acknowledgement */
;;;449        I2Cx->CR1 |= CR1_ACK_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4426280          ORR      r2,r2,#0x400
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L2.22|
                  |L2.12|
;;;450      }
;;;451      else
;;;452      {
;;;453        /* Disable the acknowledgement */
;;;454        I2Cx->CR1 &= CR1_ACK_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f33ff          MOV      r3,#0xfbff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L2.22|
;;;455      }
;;;456    }
000016  4770              BX       lr
;;;457    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;801      */
;;;802    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L3.12|
;;;803    {
;;;804      /* Check the parameters */
;;;805      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;806      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;807      if (NewState != DISABLE)
;;;808      {
;;;809        /* Enable the selected I2C PEC calculation */
;;;810        I2Cx->CR1 |= CR1_ENPEC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420220          ORR      r2,r2,#0x20
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L3.22|
                  |L3.12|
;;;811      }
;;;812      else
;;;813      {
;;;814        /* Disable the selected I2C PEC calculation */
;;;815        I2Cx->CR1 &= CR1_ENPEC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73df          MOV      r3,#0xffdf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L3.22|
;;;816      }
;;;817    }
000016  4770              BX       lr
;;;818    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1028     */
;;;1029   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  b570              PUSH     {r4-r6,lr}
;;;1030   {
000002  4602              MOV      r2,r0
;;;1031     uint32_t lastevent = 0;
000004  2400              MOVS     r4,#0
;;;1032     uint32_t flag1 = 0, flag2 = 0;
000006  2500              MOVS     r5,#0
000008  2300              MOVS     r3,#0
;;;1033     ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;1034   
;;;1035     /* Check the parameters */
;;;1036     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1037     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1038   
;;;1039     /* Read the I2Cx status register */
;;;1040     flag1 = I2Cx->SR1;
00000c  8a95              LDRH     r5,[r2,#0x14]
;;;1041     flag2 = I2Cx->SR2;
00000e  8b13              LDRH     r3,[r2,#0x18]
;;;1042     flag2 = flag2 << 16;
000010  041b              LSLS     r3,r3,#16
;;;1043   
;;;1044     /* Get the last event value from I2C status register */
;;;1045     lastevent = (flag1 | flag2) & FLAG_Mask;
000012  ea450603          ORR      r6,r5,r3
000016  f026447f          BIC      r4,r6,#0xff000000
;;;1046   
;;;1047     /* Check whether the last event contains the I2C_EVENT */
;;;1048     if ((lastevent & I2C_EVENT) == I2C_EVENT)
00001a  ea040601          AND      r6,r4,r1
00001e  428e              CMP      r6,r1
000020  d101              BNE      |L4.38|
;;;1049     {
;;;1050       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1051       status = SUCCESS;
000022  2001              MOVS     r0,#1
000024  e000              B        |L4.40|
                  |L4.38|
;;;1052     }
;;;1053     else
;;;1054     {
;;;1055       /* ERROR: last event is different from I2C_EVENT */
;;;1056       status = ERROR;
000026  2000              MOVS     r0,#0
                  |L4.40|
;;;1057     }
;;;1058     /* Return status */
;;;1059     return status;
;;;1060   }
000028  bd70              POP      {r4-r6,pc}
;;;1061   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1210     */
;;;1211   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  2200              MOVS     r2,#0
;;;1212   {
;;;1213     uint32_t flagpos = 0;
;;;1214     /* Check the parameters */
;;;1215     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1216     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1217     /* Get the I2C flag position */
;;;1218     flagpos = I2C_FLAG & FLAG_Mask;
000002  f021427f          BIC      r2,r1,#0xff000000
;;;1219     /* Clear the selected I2C flag */
;;;1220     I2Cx->SR1 = (uint16_t)~flagpos;
000006  43d3              MVNS     r3,r2
000008  8283              STRH     r3,[r0,#0x14]
;;;1221   }
00000a  4770              BX       lr
;;;1222   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1305     */
;;;1306   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  2200              MOVS     r2,#0
;;;1307   {
;;;1308     uint32_t flagpos = 0;
;;;1309     /* Check the parameters */
;;;1310     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1311     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1312     /* Get the I2C flag position */
;;;1313     flagpos = I2C_IT & FLAG_Mask;
000002  f021427f          BIC      r2,r1,#0xff000000
;;;1314     /* Clear the selected I2C flag */
;;;1315     I2Cx->SR1 = (uint16_t)~flagpos;
000006  43d3              MVNS     r3,r2
000008  8283              STRH     r3,[r0,#0x14]
;;;1316   }
00000a  4770              BX       lr
;;;1317   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;320      */
;;;321    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L7.12|
;;;322    {
;;;323      /* Check the parameters */
;;;324      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;325      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;326      if (NewState != DISABLE)
;;;327      {
;;;328        /* Enable the selected I2C peripheral */
;;;329        I2Cx->CR1 |= CR1_PE_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L7.22|
                  |L7.12|
;;;330      }
;;;331      else
;;;332      {
;;;333        /* Disable the selected I2C peripheral */
;;;334        I2Cx->CR1 &= CR1_PE_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L7.22|
;;;335      }
;;;336    }
000016  4770              BX       lr
;;;337    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;344      */
;;;345    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;346    {
;;;347      /* Check the parameters */
;;;348      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;349      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;350      if (NewState != DISABLE)
;;;351      {
;;;352        /* Enable the selected I2C DMA requests */
;;;353        I2Cx->CR2 |= CR2_DMAEN_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f4426200          ORR      r2,r2,#0x800
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;354      }
;;;355      else
;;;356      {
;;;357        /* Disable the selected I2C DMA requests */
;;;358        I2Cx->CR2 &= CR2_DMAEN_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f24f73ff          MOV      r3,#0xf7ff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;359      }
;;;360    }
000016  4770              BX       lr
;;;361    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;368      */
;;;369    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L9.12|
;;;370    {
;;;371      /* Check the parameters */
;;;372      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;373      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;374      if (NewState != DISABLE)
;;;375      {
;;;376        /* Next DMA transfer is the last transfer */
;;;377        I2Cx->CR2 |= CR2_LAST_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L9.22|
                  |L9.12|
;;;378      }
;;;379      else
;;;380      {
;;;381        /* Next DMA transfer is not the last transfer */
;;;382        I2Cx->CR2 &= CR2_LAST_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L9.22|
;;;383      }
;;;384    }
000016  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;160      */
;;;161    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;162    {
000002  4604              MOV      r4,r0
;;;163      /* Check the parameters */
;;;164      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;165    
;;;166      if (I2Cx == I2C1)
000004  480b              LDR      r0,|L10.52|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L10.30|
;;;167      {
;;;168        /* Enable I2C1 reset state */
;;;169        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0548              LSLS     r0,r1,#21
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;170        /* Release I2C1 from reset state */
;;;171        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f44f1000          MOV      r0,#0x200000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e008              B        |L10.48|
                  |L10.30|
;;;172      }
;;;173      else
;;;174      {
;;;175        /* Enable I2C2 reset state */
;;;176        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0588              LSLS     r0,r1,#22
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;177        /* Release I2C2 from reset state */
;;;178        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
000026  2100              MOVS     r1,#0
000028  f44f0080          MOV      r0,#0x400000
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L10.48|
;;;179      }
;;;180    }
000030  bd10              POP      {r4,pc}
;;;181    
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      0x40005400

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;490      */
;;;491    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L11.12|
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;495      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;496      if (NewState != DISABLE)
;;;497      {
;;;498        /* Enable dual addressing mode */
;;;499        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L11.22|
                  |L11.12|
;;;500      }
;;;501      else
;;;502      {
;;;503        /* Disable dual addressing mode */
;;;504        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L11.22|
;;;505      }
;;;506    }
000016  4770              BX       lr
;;;507    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;888      */
;;;889    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;890    {
;;;891      /* Check the parameters */
;;;892      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;893      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;894      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000004  d005              BEQ      |L12.18|
;;;895      {
;;;896        /* I2C fast mode Tlow/Thigh=2 */
;;;897        I2Cx->CCR &= I2C_DutyCycle_2;
000006  8b82              LDRH     r2,[r0,#0x1c]
000008  f64b73ff          MOV      r3,#0xbfff
00000c  401a              ANDS     r2,r2,r3
00000e  8382              STRH     r2,[r0,#0x1c]
000010  e003              B        |L12.26|
                  |L12.18|
;;;898      }
;;;899      else
;;;900      {
;;;901        /* I2C fast mode Tlow/Thigh=16/9 */
;;;902        I2Cx->CCR |= I2C_DutyCycle_16_9;
000012  8b82              LDRH     r2,[r0,#0x1c]
000014  f4424280          ORR      r2,r2,#0x4000
000018  8382              STRH     r2,[r0,#0x1c]
                  |L12.26|
;;;903      }
;;;904    }
00001a  4770              BX       lr
;;;905    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;514      */
;;;515    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;516    {
;;;517      /* Check the parameters */
;;;518      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;519      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;520      if (NewState != DISABLE)
;;;521      {
;;;522        /* Enable generall call */
;;;523        I2Cx->CR1 |= CR1_ENGC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420240          ORR      r2,r2,#0x40
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;524      }
;;;525      else
;;;526      {
;;;527        /* Disable generall call */
;;;528        I2Cx->CR1 &= CR1_ENGC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73bf          MOV      r3,#0xffbf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L13.22|
;;;529      }
;;;530    }
000016  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;392      */
;;;393    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L14.12|
;;;394    {
;;;395      /* Check the parameters */
;;;396      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;397      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;398      if (NewState != DISABLE)
;;;399      {
;;;400        /* Generate a START condition */
;;;401        I2Cx->CR1 |= CR1_START_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427280          ORR      r2,r2,#0x100
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L14.22|
                  |L14.12|
;;;402      }
;;;403      else
;;;404      {
;;;405        /* Disable the START condition generation */
;;;406        I2Cx->CR1 &= CR1_START_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f63ff          MOV      r3,#0xfeff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L14.22|
;;;407      }
;;;408    }
000016  4770              BX       lr
;;;409    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;416      */
;;;417    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L15.12|
;;;418    {
;;;419      /* Check the parameters */
;;;420      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;421      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;422      if (NewState != DISABLE)
;;;423      {
;;;424        /* Generate a STOP condition */
;;;425        I2Cx->CR1 |= CR1_STOP_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427200          ORR      r2,r2,#0x200
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L15.22|
                  |L15.12|
;;;426      }
;;;427      else
;;;428      {
;;;429        /* Disable the STOP condition generation */
;;;430        I2Cx->CR1 &= CR1_STOP_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f53ff          MOV      r3,#0xfdff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L15.22|
;;;431      }
;;;432    }
000016  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1131     */
;;;1132   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b50c              PUSH     {r2,r3,lr}
;;;1133   {
000002  4602              MOV      r2,r0
;;;1134     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1135     __IO uint32_t i2creg = 0, i2cxbase = 0;
000006  2300              MOVS     r3,#0
000008  9301              STR      r3,[sp,#4]
00000a  9300              STR      r3,[sp,#0]
;;;1136   
;;;1137     /* Check the parameters */
;;;1138     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1139     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1140   
;;;1141     /* Get the I2Cx peripheral base address */
;;;1142     i2cxbase = (uint32_t)I2Cx;
00000c  9200              STR      r2,[sp,#0]
;;;1143     
;;;1144     /* Read flag register index */
;;;1145     i2creg = I2C_FLAG >> 28;
00000e  0f0b              LSRS     r3,r1,#28
000010  9301              STR      r3,[sp,#4]
;;;1146     
;;;1147     /* Get bit[23:0] of the flag */
;;;1148     I2C_FLAG &= FLAG_Mask;
000012  f021417f          BIC      r1,r1,#0xff000000
;;;1149     
;;;1150     if(i2creg != 0)
000016  9b01              LDR      r3,[sp,#4]
000018  b11b              CBZ      r3,|L16.34|
;;;1151     {
;;;1152       /* Get the I2Cx SR1 register address */
;;;1153       i2cxbase += 0x14;
00001a  9b00              LDR      r3,[sp,#0]
00001c  3314              ADDS     r3,r3,#0x14
00001e  9300              STR      r3,[sp,#0]
000020  e003              B        |L16.42|
                  |L16.34|
;;;1154     }
;;;1155     else
;;;1156     {
;;;1157       /* Flag in I2Cx SR2 Register */
;;;1158       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
000022  0c09              LSRS     r1,r1,#16
;;;1159       /* Get the I2Cx SR2 register address */
;;;1160       i2cxbase += 0x18;
000024  9b00              LDR      r3,[sp,#0]
000026  3318              ADDS     r3,r3,#0x18
000028  9300              STR      r3,[sp,#0]
                  |L16.42|
;;;1161     }
;;;1162     
;;;1163     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00002a  9b00              LDR      r3,[sp,#0]
00002c  681b              LDR      r3,[r3,#0]
00002e  400b              ANDS     r3,r3,r1
000030  b10b              CBZ      r3,|L16.54|
;;;1164     {
;;;1165       /* I2C_FLAG is set */
;;;1166       bitstatus = SET;
000032  2001              MOVS     r0,#1
000034  e000              B        |L16.56|
                  |L16.54|
;;;1167     }
;;;1168     else
;;;1169     {
;;;1170       /* I2C_FLAG is reset */
;;;1171       bitstatus = RESET;
000036  2000              MOVS     r0,#0
                  |L16.56|
;;;1172     }
;;;1173     
;;;1174     /* Return the I2C_FLAG status */
;;;1175     return  bitstatus;
;;;1176   }
000038  bd0c              POP      {r2,r3,pc}
;;;1177   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1244     */
;;;1245   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1246   {
000002  4602              MOV      r2,r0
;;;1247     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1248     uint32_t enablestatus = 0;
000006  2300              MOVS     r3,#0
;;;1249   
;;;1250     /* Check the parameters */
;;;1251     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1252     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1253   
;;;1254     /* Check if the interrupt source is enabled or not */
;;;1255     enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
000008  8894              LDRH     r4,[r2,#4]
00000a  f00165e0          AND      r5,r1,#0x7000000
00000e  ea044315          AND      r3,r4,r5,LSR #16
;;;1256     
;;;1257     /* Get bit[23:0] of the flag */
;;;1258     I2C_IT &= FLAG_Mask;
000012  f021417f          BIC      r1,r1,#0xff000000
;;;1259   
;;;1260     /* Check the status of the specified I2C flag */
;;;1261     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000016  8a94              LDRH     r4,[r2,#0x14]
000018  400c              ANDS     r4,r4,r1
00001a  b114              CBZ      r4,|L17.34|
00001c  b10b              CBZ      r3,|L17.34|
;;;1262     {
;;;1263       /* I2C_IT is set */
;;;1264       bitstatus = SET;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L17.36|
                  |L17.34|
;;;1265     }
;;;1266     else
;;;1267     {
;;;1268       /* I2C_IT is reset */
;;;1269       bitstatus = RESET;
000022  2000              MOVS     r0,#0
                  |L17.36|
;;;1270     }
;;;1271     /* Return the I2C_IT status */
;;;1272     return  bitstatus;
;;;1273   }
000024  bd30              POP      {r4,r5,pc}
;;;1274   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1076     */
;;;1077   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;1078   {
000002  4601              MOV      r1,r0
;;;1079     uint32_t lastevent = 0;
000004  2000              MOVS     r0,#0
;;;1080     uint32_t flag1 = 0, flag2 = 0;
000006  2300              MOVS     r3,#0
000008  2200              MOVS     r2,#0
;;;1081   
;;;1082     /* Check the parameters */
;;;1083     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1084   
;;;1085     /* Read the I2Cx status register */
;;;1086     flag1 = I2Cx->SR1;
00000a  8a8b              LDRH     r3,[r1,#0x14]
;;;1087     flag2 = I2Cx->SR2;
00000c  8b0a              LDRH     r2,[r1,#0x18]
;;;1088     flag2 = flag2 << 16;
00000e  0412              LSLS     r2,r2,#16
;;;1089   
;;;1090     /* Get the last event value from I2C status register */
;;;1091     lastevent = (flag1 | flag2) & FLAG_Mask;
000010  ea430402          ORR      r4,r3,r2
000014  f024407f          BIC      r0,r4,#0xff000000
;;;1092   
;;;1093     /* Return status */
;;;1094     return lastevent;
;;;1095   }
000018  bd10              POP      {r4,pc}
;;;1096   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;823      */
;;;824    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;825    {
;;;826      /* Check the parameters */
;;;827      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;828      /* Return the selected I2C PEC value */
;;;829      return ((I2Cx->SR2) >> 8);
000002  8b08              LDRH     r0,[r1,#0x18]
000004  1200              ASRS     r0,r0,#8
;;;830    }
000006  4770              BX       lr
;;;831    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;543      */
;;;544    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;545    {
;;;546      /* Check the parameters */
;;;547      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;548      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;549      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;550      
;;;551      if (NewState != DISABLE)
;;;552      {
;;;553        /* Enable the selected I2C interrupts */
;;;554        I2Cx->CR2 |= I2C_IT;
000002  8883              LDRH     r3,[r0,#4]
000004  430b              ORRS     r3,r3,r1
000006  8083              STRH     r3,[r0,#4]
000008  e002              B        |L20.16|
                  |L20.10|
;;;555      }
;;;556      else
;;;557      {
;;;558        /* Disable the selected I2C interrupts */
;;;559        I2Cx->CR2 &= (uint16_t)~I2C_IT;
00000a  8883              LDRH     r3,[r0,#4]
00000c  438b              BICS     r3,r3,r1
00000e  8083              STRH     r3,[r0,#4]
                  |L20.16|
;;;560      }
;;;561    }
000010  4770              BX       lr
;;;562    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;189      */
;;;190    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;191    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;192      uint16_t tmpreg = 0, freqrange = 0;
00000a  2600              MOVS     r6,#0
00000c  46b1              MOV      r9,r6
;;;193      uint16_t result = 0x04;
00000e  2704              MOVS     r7,#4
;;;194      uint32_t pclk1 = 8000000;
000010  f8df80cc          LDR      r8,|L21.224|
;;;195      RCC_ClocksTypeDef  rcc_clocks;
;;;196      /* Check the parameters */
;;;197      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;198      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;199      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;200      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;201      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;202      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;203      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;204    
;;;205    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;206      /* Get the I2Cx CR2 value */
;;;207      tmpreg = I2Cx->CR2;
000014  88a6              LDRH     r6,[r4,#4]
;;;208      /* Clear frequency FREQ[5:0] bits */
;;;209      tmpreg &= CR2_FREQ_Reset;
000016  f64f70c0          MOV      r0,#0xffc0
00001a  4006              ANDS     r6,r6,r0
;;;210      /* Get pclk1 frequency value */
;;;211      RCC_GetClocksFreq(&rcc_clocks);
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       RCC_GetClocksFreq
;;;212      pclk1 = rcc_clocks.PCLK1_Frequency;
000022  f8dd8008          LDR      r8,[sp,#8]
;;;213      /* Set frequency bits depending on pclk1 value */
;;;214      freqrange = (uint16_t)(pclk1 / 1000000);
000026  482f              LDR      r0,|L21.228|
000028  fbb8f0f0          UDIV     r0,r8,r0
00002c  fa1ff980          UXTH     r9,r0
;;;215      tmpreg |= freqrange;
000030  ea460609          ORR      r6,r6,r9
;;;216      /* Write to I2Cx CR2 */
;;;217      I2Cx->CR2 = tmpreg;
000034  80a6              STRH     r6,[r4,#4]
;;;218    
;;;219    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;220      /* Disable the selected I2C peripheral to configure TRISE */
;;;221      I2Cx->CR1 &= CR1_PE_Reset;
000036  8820              LDRH     r0,[r4,#0]
000038  f64f71fe          MOV      r1,#0xfffe
00003c  4008              ANDS     r0,r0,r1
00003e  8020              STRH     r0,[r4,#0]
;;;222      /* Reset tmpreg value */
;;;223      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;224      tmpreg = 0;
000040  2600              MOVS     r6,#0
;;;225    
;;;226      /* Configure speed in standard mode */
;;;227      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000042  4929              LDR      r1,|L21.232|
000044  6828              LDR      r0,[r5,#0]
000046  4288              CMP      r0,r1
000048  d80c              BHI      |L21.100|
;;;228      {
;;;229        /* Standard mode speed calculate */
;;;230        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
00004a  6828              LDR      r0,[r5,#0]
00004c  0040              LSLS     r0,r0,#1
00004e  fbb8f0f0          UDIV     r0,r8,r0
000052  b287              UXTH     r7,r0
;;;231        /* Test if CCR value is under 0x4*/
;;;232        if (result < 0x04)
000054  2f04              CMP      r7,#4
000056  da00              BGE      |L21.90|
;;;233        {
;;;234          /* Set minimum allowed value */
;;;235          result = 0x04;  
000058  2704              MOVS     r7,#4
                  |L21.90|
;;;236        }
;;;237        /* Set speed value for standard mode */
;;;238        tmpreg |= result;	  
00005a  433e              ORRS     r6,r6,r7
;;;239        /* Set Maximum Rise Time for standard mode */
;;;240        I2Cx->TRISE = freqrange + 1; 
00005c  f1090001          ADD      r0,r9,#1
000060  8420              STRH     r0,[r4,#0x20]
000062  e027              B        |L21.180|
                  |L21.100|
;;;241      }
;;;242      /* Configure speed in fast mode */
;;;243      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;244      {
;;;245        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000064  88e8              LDRH     r0,[r5,#6]
000066  f64b71ff          MOV      r1,#0xbfff
00006a  4288              CMP      r0,r1
00006c  d106              BNE      |L21.124|
;;;246        {
;;;247          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;248          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
00006e  6828              LDR      r0,[r5,#0]
000070  eb000040          ADD      r0,r0,r0,LSL #1
000074  fbb8f0f0          UDIV     r0,r8,r0
000078  b287              UXTH     r7,r0
00007a  e009              B        |L21.144|
                  |L21.124|
;;;249        }
;;;250        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;251        {
;;;252          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;253          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
00007c  6828              LDR      r0,[r5,#0]
00007e  eb0001c0          ADD      r1,r0,r0,LSL #3
000082  eb011000          ADD      r0,r1,r0,LSL #4
000086  fbb8f0f0          UDIV     r0,r8,r0
00008a  b287              UXTH     r7,r0
;;;254          /* Set DUTY bit */
;;;255          result |= I2C_DutyCycle_16_9;
00008c  f4474780          ORR      r7,r7,#0x4000
                  |L21.144|
;;;256        }
;;;257    
;;;258        /* Test if CCR value is under 0x1*/
;;;259        if ((result & CCR_CCR_Set) == 0)
000090  f3c7000b          UBFX     r0,r7,#0,#12
000094  b908              CBNZ     r0,|L21.154|
;;;260        {
;;;261          /* Set minimum allowed value */
;;;262          result |= (uint16_t)0x0001;  
000096  f0470701          ORR      r7,r7,#1
                  |L21.154|
;;;263        }
;;;264        /* Set speed value and set F/S bit for fast mode */
;;;265        tmpreg |= (uint16_t)(result | CCR_FS_Set);
00009a  f4474000          ORR      r0,r7,#0x8000
00009e  4306              ORRS     r6,r6,r0
;;;266        /* Set Maximum Rise Time for fast mode */
;;;267        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
0000a0  f44f7096          MOV      r0,#0x12c
0000a4  fb09f000          MUL      r0,r9,r0
0000a8  f44f717a          MOV      r1,#0x3e8
0000ac  fb90f0f1          SDIV     r0,r0,r1
0000b0  1c40              ADDS     r0,r0,#1
0000b2  8420              STRH     r0,[r4,#0x20]
                  |L21.180|
;;;268      }
;;;269    
;;;270      /* Write to I2Cx CCR */
;;;271      I2Cx->CCR = tmpreg;
0000b4  83a6              STRH     r6,[r4,#0x1c]
;;;272      /* Enable the selected I2C peripheral */
;;;273      I2Cx->CR1 |= CR1_PE_Set;
0000b6  8820              LDRH     r0,[r4,#0]
0000b8  f0400001          ORR      r0,r0,#1
0000bc  8020              STRH     r0,[r4,#0]
;;;274    
;;;275    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;276      /* Get the I2Cx CR1 value */
;;;277      tmpreg = I2Cx->CR1;
0000be  8826              LDRH     r6,[r4,#0]
;;;278      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;279      tmpreg &= CR1_CLEAR_Mask;
0000c0  f64f30f5          MOV      r0,#0xfbf5
0000c4  4006              ANDS     r6,r6,r0
;;;280      /* Configure I2Cx: mode and acknowledgement */
;;;281      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;282      /* Set ACK bit according to I2C_Ack value */
;;;283      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000c6  88a8              LDRH     r0,[r5,#4]
0000c8  8969              LDRH     r1,[r5,#0xa]
0000ca  4308              ORRS     r0,r0,r1
0000cc  4306              ORRS     r6,r6,r0
;;;284      /* Write to I2Cx CR1 */
;;;285      I2Cx->CR1 = tmpreg;
0000ce  8026              STRH     r6,[r4,#0]
;;;286    
;;;287    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;288      /* Set I2Cx Own Address1 and acknowledged address */
;;;289      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000d0  89a8              LDRH     r0,[r5,#0xc]
0000d2  8929              LDRH     r1,[r5,#8]
0000d4  4308              ORRS     r0,r0,r1
0000d6  8120              STRH     r0,[r4,#8]
;;;290    }
0000d8  b005              ADD      sp,sp,#0x14
0000da  e8bd83f0          POP      {r4-r9,pc}
;;;291    
                          ENDP

0000de  0000              DCW      0x0000
                  |L21.224|
                          DCD      0x007a1200
                  |L21.228|
                          DCD      0x000f4240
                  |L21.232|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;694      */
;;;695    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;696    {
;;;697      /* Check the parameters */
;;;698      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;699      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;700      
;;;701      /* Check the input parameter */
;;;702      if (I2C_NACKPosition == I2C_NACKPosition_Next)
000004  d104              BNE      |L22.16|
;;;703      {
;;;704        /* Next byte in shift register is the last received byte */
;;;705        I2Cx->CR1 |= I2C_NACKPosition_Next;
000006  8802              LDRH     r2,[r0,#0]
000008  f4426200          ORR      r2,r2,#0x800
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L22.26|
                  |L22.16|
;;;706      }
;;;707      else
;;;708      {
;;;709        /* Current byte in shift register is the last received byte */
;;;710        I2Cx->CR1 &= I2C_NACKPosition_Current;
000010  8802              LDRH     r2,[r0,#0]
000012  f24f73ff          MOV      r3,#0xf7ff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L22.26|
;;;711      }
;;;712    }
00001a  4770              BX       lr
;;;713    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;463      */
;;;464    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  460a              MOV      r2,r1
;;;465    {
;;;466      uint16_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;467    
;;;468      /* Check the parameters */
;;;469      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;470    
;;;471      /* Get the old register value */
;;;472      tmpreg = I2Cx->OAR2;
000004  8981              LDRH     r1,[r0,#0xc]
;;;473    
;;;474      /* Reset I2Cx Own address2 bit [7:1] */
;;;475      tmpreg &= OAR2_ADD2_Reset;
000006  f64f7301          MOV      r3,#0xff01
00000a  4019              ANDS     r1,r1,r3
;;;476    
;;;477      /* Set I2Cx Own address2 */
;;;478      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
00000c  f00203fe          AND      r3,r2,#0xfe
000010  4319              ORRS     r1,r1,r3
;;;479    
;;;480      /* Store the new register value */
;;;481      I2Cx->OAR2 = tmpreg;
000012  8181              STRH     r1,[r0,#0xc]
;;;482    }
000014  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;777      */
;;;778    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;779    {
;;;780      /* Check the parameters */
;;;781      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;782      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;783      if (I2C_PECPosition == I2C_PECPosition_Next)
000004  d104              BNE      |L24.16|
;;;784      {
;;;785        /* Next byte in shift register is PEC */
;;;786        I2Cx->CR1 |= I2C_PECPosition_Next;
000006  8802              LDRH     r2,[r0,#0]
000008  f4426200          ORR      r2,r2,#0x800
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L24.26|
                  |L24.16|
;;;787      }
;;;788      else
;;;789      {
;;;790        /* Current byte in shift register is PEC */
;;;791        I2Cx->CR1 &= I2C_PECPosition_Current;
000010  8802              LDRH     r2,[r0,#0]
000012  f24f73ff          MOV      r3,#0xf7ff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L24.26|
;;;792      }
;;;793    }
00001a  4770              BX       lr
;;;794    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;634      */
;;;635    uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b508              PUSH     {r3,lr}
;;;636    {
000002  4602              MOV      r2,r0
;;;637      __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;638    
;;;639      /* Check the parameters */
;;;640      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;641      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;642    
;;;643      tmp = (uint32_t) I2Cx;
000008  9200              STR      r2,[sp,#0]
;;;644      tmp += I2C_Register;
00000a  9800              LDR      r0,[sp,#0]
00000c  4408              ADD      r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;645    
;;;646      /* Return the selected register value */
;;;647      return (*(__IO uint16_t *) tmp);
000010  9800              LDR      r0,[sp,#0]
000012  8800              LDRH     r0,[r0,#0]
;;;648    }
000014  bd08              POP      {r3,pc}
;;;649    
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;581      */
;;;582    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;583    {
;;;584      /* Check the parameters */
;;;585      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;586      /* Return the data in the DR register */
;;;587      return (uint8_t)I2Cx->DR;
000002  8a08              LDRH     r0,[r1,#0x10]
000004  b2c0              UXTB     r0,r0
;;;588    }
000006  4770              BX       lr
;;;589    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;722      */
;;;723    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;724    {
;;;725      /* Check the parameters */
;;;726      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;727      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;728      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000004  d104              BNE      |L27.16|
;;;729      {
;;;730        /* Drive the SMBusAlert pin Low */
;;;731        I2Cx->CR1 |= I2C_SMBusAlert_Low;
000006  8802              LDRH     r2,[r0,#0]
000008  f4425200          ORR      r2,r2,#0x2000
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L27.26|
                  |L27.16|
;;;732      }
;;;733      else
;;;734      {
;;;735        /* Drive the SMBusAlert pin High  */
;;;736        I2Cx->CR1 &= I2C_SMBusAlert_High;
000010  8802              LDRH     r2,[r0,#0]
000012  f64d73ff          MOV      r3,#0xdfff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L27.26|
;;;737      }
;;;738    }
00001a  4770              BX       lr
;;;739    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;599      */
;;;600    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L28.8|
;;;601    {
;;;602      /* Check the parameters */
;;;603      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;604      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;605      /* Test on the direction to set/reset the read/write bit */
;;;606      if (I2C_Direction != I2C_Direction_Transmitter)
;;;607      {
;;;608        /* Set the address bit0 for read */
;;;609        Address |= OAR1_ADD0_Set;
000002  f0410101          ORR      r1,r1,#1
000006  e002              B        |L28.14|
                  |L28.8|
;;;610      }
;;;611      else
;;;612      {
;;;613        /* Reset the address bit0 for write */
;;;614        Address &= OAR1_ADD0_Reset;
000008  f64f73fe          MOV      r3,#0xfffe
00000c  4019              ANDS     r1,r1,r3
                  |L28.14|
;;;615      }
;;;616      /* Send the address */
;;;617      I2Cx->DR = Address;
00000e  8201              STRH     r1,[r0,#0x10]
;;;618    }
000010  4770              BX       lr
;;;619    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;568      */
;;;569    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;570    {
;;;571      /* Check the parameters */
;;;572      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;573      /* Write in the DR register the data to be sent */
;;;574      I2Cx->DR = Data;
;;;575    }
000002  4770              BX       lr
;;;576    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;656      */
;;;657    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L30.12|
;;;658    {
;;;659      /* Check the parameters */
;;;660      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;661      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;662      if (NewState != DISABLE)
;;;663      {
;;;664        /* Peripheral under reset */
;;;665        I2Cx->CR1 |= CR1_SWRST_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4424200          ORR      r2,r2,#0x8000
000008  8002              STRH     r2,[r0,#0]
00000a  e003              B        |L30.20|
                  |L30.12|
;;;666      }
;;;667      else
;;;668      {
;;;669        /* Peripheral not under reset */
;;;670        I2Cx->CR1 &= CR1_SWRST_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f3c2020e          UBFX     r2,r2,#0,#15
000012  8002              STRH     r2,[r0,#0]
                  |L30.20|
;;;671      }
;;;672    }
000014  4770              BX       lr
;;;673    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;862      */
;;;863    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b921              CBNZ     r1,|L31.12|
;;;864    {
;;;865      /* Check the parameters */
;;;866      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;867      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;868      if (NewState == DISABLE)
;;;869      {
;;;870        /* Enable the selected I2C Clock stretching */
;;;871        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L31.22|
                  |L31.12|
;;;872      }
;;;873      else
;;;874      {
;;;875        /* Disable the selected I2C Clock stretching */
;;;876        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L31.22|
;;;877      }
;;;878    }
000016  4770              BX       lr
;;;879    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;296      */
;;;297    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;298    {
;;;299    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;300      /* initialize the I2C_ClockSpeed member */
;;;301      I2C_InitStruct->I2C_ClockSpeed = 5000;
000004  6001              STR      r1,[r0,#0]
;;;302      /* Initialize the I2C_Mode member */
;;;303      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;304      /* Initialize the I2C_DutyCycle member */
;;;305      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b71ff          MOV      r1,#0xbfff
00000e  80c1              STRH     r1,[r0,#6]
;;;306      /* Initialize the I2C_OwnAddress1 member */
;;;307      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  2100              MOVS     r1,#0
000012  8101              STRH     r1,[r0,#8]
;;;308      /* Initialize the I2C_Ack member */
;;;309      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000014  8141              STRH     r1,[r0,#0xa]
;;;310      /* Initialize the I2C_AcknowledgedAddress member */
;;;311      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000016  f44f4180          MOV      r1,#0x4000
00001a  8181              STRH     r1,[r0,#0xc]
;;;312    }
00001c  4770              BX       lr
;;;313    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;746      */
;;;747    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L33.12|
;;;748    {
;;;749      /* Check the parameters */
;;;750      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;751      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;752      if (NewState != DISABLE)
;;;753      {
;;;754        /* Enable the selected I2C PEC transmission */
;;;755        I2Cx->CR1 |= CR1_PEC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L33.22|
                  |L33.12|
;;;756      }
;;;757      else
;;;758      {
;;;759        /* Disable the selected I2C PEC transmission */
;;;760        I2Cx->CR1 &= CR1_PEC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L33.22|
;;;761      }
;;;762    }
000016  4770              BX       lr
;;;763    
                          ENDP

