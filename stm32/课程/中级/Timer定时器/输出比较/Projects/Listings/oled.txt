; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\oled.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\output\oled.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Drivers\CMSIS -I..\Drivers\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\Drivers\BSP\SYS -I..\Drivers\BSP\SYSTICK -I..\Drivers\BSP\USART -I..\Middlewares\FreeRTOS\include -I..\Middlewares\FreeRTOS\portable\RVDS\ARM_CM3 -I..\Drivers\BSP\LED -I..\Drivers\BSP\OLED -I..\Drivers\BSP\TIM -I..\Drivers\BSP\PWM -I..\Drivers\BSP\SYSTICK -I..\Drivers\BSP\SYS -ID:\AppData\keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=540 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\output\oled.crf ..\Drivers\BSP\OLED\OLED.c]
                          THUMB

                          AREA ||i.OLED_Clear||, CODE, READONLY, ALIGN=2

                  OLED_Clear PROC
;;;469     */
;;;470    void OLED_Clear(void)
000000  2000              MOVS     r0,#0
;;;471    {
;;;472    	uint8_t i, j;
;;;473    	for (j = 0; j < 8; j++) // 遍历8页
000002  e00c              B        |L1.30|
                  |L1.4|
;;;474    	{
;;;475    		for (i = 0; i < 128; i++) // 遍历128列
000004  2100              MOVS     r1,#0
000006  e006              B        |L1.22|
                  |L1.8|
;;;476    		{
;;;477    			OLED_DisplayBuf[j][i] = 0x00; // 将显存数组数据全部清零
000008  2200              MOVS     r2,#0
00000a  4b06              LDR      r3,|L1.36|
00000c  eb0313c0          ADD      r3,r3,r0,LSL #7
000010  545a              STRB     r2,[r3,r1]
000012  1c4a              ADDS     r2,r1,#1              ;475
000014  b2d1              UXTB     r1,r2                 ;475
                  |L1.22|
000016  2980              CMP      r1,#0x80              ;475
000018  dbf6              BLT      |L1.8|
00001a  1c42              ADDS     r2,r0,#1              ;473
00001c  b2d0              UXTB     r0,r2                 ;473
                  |L1.30|
00001e  2808              CMP      r0,#8                 ;473
000020  dbf0              BLT      |L1.4|
;;;478    		}
;;;479    	}
;;;480    }
000022  4770              BX       lr
;;;481    
                          ENDP

                  |L1.36|
                          DCD      OLED_DisplayBuf

                          AREA ||i.OLED_ClearArea||, CODE, READONLY, ALIGN=2

                  OLED_ClearArea PROC
;;;490     */
;;;491    void OLED_ClearArea(int16_t X, int16_t Y, uint8_t Width, uint8_t Height)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;492    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;493    	int16_t i, j;
;;;494    
;;;495    	for (j = Y; j < Y + Height; j++) // 遍历指定页
00000c  4628              MOV      r0,r5
00000e  e038              B        |L2.130|
                  |L2.16|
;;;496    	{
;;;497    		for (i = X; i < X + Width; i++) // 遍历指定列
000010  4622              MOV      r2,r4
000012  e031              B        |L2.120|
                  |L2.20|
;;;498    		{
;;;499    			if (i >= 0 && i <= 127 && j >= 0 && j <= 63) // 超出屏幕的内容不显示
000014  2a00              CMP      r2,#0
000016  db2d              BLT      |L2.116|
000018  2a7f              CMP      r2,#0x7f
00001a  dc2b              BGT      |L2.116|
00001c  2800              CMP      r0,#0
00001e  db29              BLT      |L2.116|
000020  283f              CMP      r0,#0x3f
000022  dc27              BGT      |L2.116|
;;;500    			{
;;;501    				OLED_DisplayBuf[j / 8][i] &= ~(0x01 << (j % 8)); // 将显存数组指定数据清零
000024  ea4f7ce0          ASR      r12,r0,#31
000028  eb007c5c          ADD      r12,r0,r12,LSR #29
00002c  ea4f0cec          ASR      r12,r12,#3
000030  f8df8058          LDR      r8,|L2.140|
000034  eb081ccc          ADD      r12,r8,r12,LSL #7
000038  f81cc002          LDRB     r12,[r12,r2]
00003c  4603              MOV      r3,r0
00003e  ea4f78e0          ASR      r8,r0,#31
000042  eb007858          ADD      r8,r0,r8,LSR #29
000046  ea4f08e8          ASR      r8,r8,#3
00004a  eba009c8          SUB      r9,r0,r8,LSL #3
00004e  f04f0801          MOV      r8,#1
000052  fa08f809          LSL      r8,r8,r9
000056  ea2c0c08          BIC      r12,r12,r8
00005a  4601              MOV      r1,r0
00005c  ea4f78e0          ASR      r8,r0,#31
000060  eb007858          ADD      r8,r0,r8,LSR #29
000064  ea4f08e8          ASR      r8,r8,#3
000068  f8df9020          LDR      r9,|L2.140|
00006c  eb0918c8          ADD      r8,r9,r8,LSL #7
000070  f808c002          STRB     r12,[r8,r2]
                  |L2.116|
000074  1c51              ADDS     r1,r2,#1              ;497
000076  b20a              SXTH     r2,r1                 ;497
                  |L2.120|
000078  19a1              ADDS     r1,r4,r6              ;497
00007a  4291              CMP      r1,r2                 ;497
00007c  dcca              BGT      |L2.20|
00007e  1c41              ADDS     r1,r0,#1              ;495
000080  b208              SXTH     r0,r1                 ;495
                  |L2.130|
000082  19e9              ADDS     r1,r5,r7              ;495
000084  4281              CMP      r1,r0                 ;495
000086  dcc3              BGT      |L2.16|
;;;502    			}
;;;503    		}
;;;504    	}
;;;505    }
000088  e8bd83f0          POP      {r4-r9,pc}
;;;506    
                          ENDP

                  |L2.140|
                          DCD      OLED_DisplayBuf

                          AREA ||i.OLED_DrawArc||, CODE, READONLY, ALIGN=1

                  OLED_DrawArc PROC
;;;1403    */
;;;1404   void OLED_DrawArc(int16_t X, int16_t Y, uint8_t Radius, int16_t StartAngle, int16_t EndAngle, uint8_t IsFilled)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1405   {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4691              MOV      r9,r2
00000a  469b              MOV      r11,r3
;;;1406   	int16_t x, y, d, j;
;;;1407   
;;;1408   	/*此函数借用Bresenham算法画圆的方法*/
;;;1409   
;;;1410   	d = 1 - Radius;
00000c  f1c90a01          RSB      r10,r9,#1
;;;1411   	x = 0;
000010  2500              MOVS     r5,#0
;;;1412   	y = Radius;
000012  464c              MOV      r4,r9
;;;1413   
;;;1414   	/*在画圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*/
;;;1415   	if (OLED_IsInAngle(x, y, StartAngle, EndAngle))
000014  465a              MOV      r2,r11
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  9b0a              LDR      r3,[sp,#0x28]
00001c  f7fffffe          BL       OLED_IsInAngle
000020  b128              CBZ      r0,|L3.46|
;;;1416   	{
;;;1417   		OLED_DrawPoint(X + x, Y + y);
000022  1932              ADDS     r2,r6,r4
000024  b211              SXTH     r1,r2
000026  197a              ADDS     r2,r7,r5
000028  b210              SXTH     r0,r2
00002a  f7fffffe          BL       OLED_DrawPoint
                  |L3.46|
;;;1418   	}
;;;1419   	if (OLED_IsInAngle(-x, -y, StartAngle, EndAngle))
00002e  465a              MOV      r2,r11
000030  4260              RSBS     r0,r4,#0
000032  b201              SXTH     r1,r0
000034  4268              RSBS     r0,r5,#0
000036  b200              SXTH     r0,r0
000038  9b0a              LDR      r3,[sp,#0x28]
00003a  f7fffffe          BL       OLED_IsInAngle
00003e  b128              CBZ      r0,|L3.76|
;;;1420   	{
;;;1421   		OLED_DrawPoint(X - x, Y - y);
000040  1b32              SUBS     r2,r6,r4
000042  b211              SXTH     r1,r2
000044  1b7a              SUBS     r2,r7,r5
000046  b210              SXTH     r0,r2
000048  f7fffffe          BL       OLED_DrawPoint
                  |L3.76|
;;;1422   	}
;;;1423   	if (OLED_IsInAngle(y, x, StartAngle, EndAngle))
00004c  465a              MOV      r2,r11
00004e  4629              MOV      r1,r5
000050  4620              MOV      r0,r4
000052  9b0a              LDR      r3,[sp,#0x28]
000054  f7fffffe          BL       OLED_IsInAngle
000058  b128              CBZ      r0,|L3.102|
;;;1424   	{
;;;1425   		OLED_DrawPoint(X + y, Y + x);
00005a  1972              ADDS     r2,r6,r5
00005c  b211              SXTH     r1,r2
00005e  193a              ADDS     r2,r7,r4
000060  b210              SXTH     r0,r2
000062  f7fffffe          BL       OLED_DrawPoint
                  |L3.102|
;;;1426   	}
;;;1427   	if (OLED_IsInAngle(-y, -x, StartAngle, EndAngle))
000066  465a              MOV      r2,r11
000068  4268              RSBS     r0,r5,#0
00006a  b201              SXTH     r1,r0
00006c  4260              RSBS     r0,r4,#0
00006e  b200              SXTH     r0,r0
000070  9b0a              LDR      r3,[sp,#0x28]
000072  f7fffffe          BL       OLED_IsInAngle
000076  b128              CBZ      r0,|L3.132|
;;;1428   	{
;;;1429   		OLED_DrawPoint(X - y, Y - x);
000078  1b72              SUBS     r2,r6,r5
00007a  b211              SXTH     r1,r2
00007c  1b3a              SUBS     r2,r7,r4
00007e  b210              SXTH     r0,r2
000080  f7fffffe          BL       OLED_DrawPoint
                  |L3.132|
;;;1430   	}
;;;1431   
;;;1432   	if (IsFilled) // 指定圆弧填充
000084  980b              LDR      r0,[sp,#0x2c]
000086  b1b0              CBZ      r0,|L3.182|
;;;1433   	{
;;;1434   		/*遍历起始点Y坐标*/
;;;1435   		for (j = -y; j < y; j++)
000088  4260              RSBS     r0,r4,#0
00008a  fa0ff880          SXTH     r8,r0
00008e  e010              B        |L3.178|
                  |L3.144|
;;;1436   		{
;;;1437   			/*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*/
;;;1438   			if (OLED_IsInAngle(0, j, StartAngle, EndAngle))
000090  465a              MOV      r2,r11
000092  4641              MOV      r1,r8
000094  2000              MOVS     r0,#0
000096  9b0a              LDR      r3,[sp,#0x28]
000098  f7fffffe          BL       OLED_IsInAngle
00009c  b128              CBZ      r0,|L3.170|
;;;1439   			{
;;;1440   				OLED_DrawPoint(X, Y + j);
00009e  eb060008          ADD      r0,r6,r8
0000a2  b201              SXTH     r1,r0
0000a4  4638              MOV      r0,r7
0000a6  f7fffffe          BL       OLED_DrawPoint
                  |L3.170|
0000aa  f1080001          ADD      r0,r8,#1              ;1435
0000ae  fa0ff880          SXTH     r8,r0                 ;1435
                  |L3.178|
0000b2  45a0              CMP      r8,r4                 ;1435
0000b4  dbec              BLT      |L3.144|
                  |L3.182|
;;;1441   			}
;;;1442   		}
;;;1443   	}
;;;1444   
;;;1445   	while (x < y) // 遍历X轴的每个点
0000b6  e0d3              B        |L3.608|
                  |L3.184|
;;;1446   	{
;;;1447   		x++;
0000b8  1c68              ADDS     r0,r5,#1
0000ba  b205              SXTH     r5,r0
;;;1448   		if (d < 0) // 下一个点在当前点东方
0000bc  f1ba0f00          CMP      r10,#0
0000c0  da05              BGE      |L3.206|
;;;1449   		{
;;;1450   			d += 2 * x + 1;
0000c2  0068              LSLS     r0,r5,#1
0000c4  1c40              ADDS     r0,r0,#1
0000c6  4450              ADD      r0,r0,r10
0000c8  fa0ffa80          SXTH     r10,r0
0000cc  e007              B        |L3.222|
                  |L3.206|
;;;1451   		}
;;;1452   		else // 下一个点在当前点东南方
;;;1453   		{
;;;1454   			y--;
0000ce  1e60              SUBS     r0,r4,#1
0000d0  b204              SXTH     r4,r0
;;;1455   			d += 2 * (x - y) + 1;
0000d2  1b28              SUBS     r0,r5,r4
0000d4  0040              LSLS     r0,r0,#1
0000d6  1c40              ADDS     r0,r0,#1
0000d8  4450              ADD      r0,r0,r10
0000da  fa0ffa80          SXTH     r10,r0
                  |L3.222|
;;;1456   		}
;;;1457   
;;;1458   		/*在画圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*/
;;;1459   		if (OLED_IsInAngle(x, y, StartAngle, EndAngle))
0000de  465a              MOV      r2,r11
0000e0  4621              MOV      r1,r4
0000e2  4628              MOV      r0,r5
0000e4  9b0a              LDR      r3,[sp,#0x28]
0000e6  f7fffffe          BL       OLED_IsInAngle
0000ea  b128              CBZ      r0,|L3.248|
;;;1460   		{
;;;1461   			OLED_DrawPoint(X + x, Y + y);
0000ec  1932              ADDS     r2,r6,r4
0000ee  b211              SXTH     r1,r2
0000f0  197a              ADDS     r2,r7,r5
0000f2  b210              SXTH     r0,r2
0000f4  f7fffffe          BL       OLED_DrawPoint
                  |L3.248|
;;;1462   		}
;;;1463   		if (OLED_IsInAngle(y, x, StartAngle, EndAngle))
0000f8  465a              MOV      r2,r11
0000fa  4629              MOV      r1,r5
0000fc  4620              MOV      r0,r4
0000fe  9b0a              LDR      r3,[sp,#0x28]
000100  f7fffffe          BL       OLED_IsInAngle
000104  b128              CBZ      r0,|L3.274|
;;;1464   		{
;;;1465   			OLED_DrawPoint(X + y, Y + x);
000106  1972              ADDS     r2,r6,r5
000108  b211              SXTH     r1,r2
00010a  193a              ADDS     r2,r7,r4
00010c  b210              SXTH     r0,r2
00010e  f7fffffe          BL       OLED_DrawPoint
                  |L3.274|
;;;1466   		}
;;;1467   		if (OLED_IsInAngle(-x, -y, StartAngle, EndAngle))
000112  465a              MOV      r2,r11
000114  4260              RSBS     r0,r4,#0
000116  b201              SXTH     r1,r0
000118  4268              RSBS     r0,r5,#0
00011a  b200              SXTH     r0,r0
00011c  9b0a              LDR      r3,[sp,#0x28]
00011e  f7fffffe          BL       OLED_IsInAngle
000122  b128              CBZ      r0,|L3.304|
;;;1468   		{
;;;1469   			OLED_DrawPoint(X - x, Y - y);
000124  1b32              SUBS     r2,r6,r4
000126  b211              SXTH     r1,r2
000128  1b7a              SUBS     r2,r7,r5
00012a  b210              SXTH     r0,r2
00012c  f7fffffe          BL       OLED_DrawPoint
                  |L3.304|
;;;1470   		}
;;;1471   		if (OLED_IsInAngle(-y, -x, StartAngle, EndAngle))
000130  465a              MOV      r2,r11
000132  4268              RSBS     r0,r5,#0
000134  b201              SXTH     r1,r0
000136  4260              RSBS     r0,r4,#0
000138  b200              SXTH     r0,r0
00013a  9b0a              LDR      r3,[sp,#0x28]
00013c  f7fffffe          BL       OLED_IsInAngle
000140  b128              CBZ      r0,|L3.334|
;;;1472   		{
;;;1473   			OLED_DrawPoint(X - y, Y - x);
000142  1b72              SUBS     r2,r6,r5
000144  b211              SXTH     r1,r2
000146  1b3a              SUBS     r2,r7,r4
000148  b210              SXTH     r0,r2
00014a  f7fffffe          BL       OLED_DrawPoint
                  |L3.334|
;;;1474   		}
;;;1475   		if (OLED_IsInAngle(x, -y, StartAngle, EndAngle))
00014e  465a              MOV      r2,r11
000150  4260              RSBS     r0,r4,#0
000152  b201              SXTH     r1,r0
000154  4628              MOV      r0,r5
000156  9b0a              LDR      r3,[sp,#0x28]
000158  f7fffffe          BL       OLED_IsInAngle
00015c  b128              CBZ      r0,|L3.362|
;;;1476   		{
;;;1477   			OLED_DrawPoint(X + x, Y - y);
00015e  1b32              SUBS     r2,r6,r4
000160  b211              SXTH     r1,r2
000162  197a              ADDS     r2,r7,r5
000164  b210              SXTH     r0,r2
000166  f7fffffe          BL       OLED_DrawPoint
                  |L3.362|
;;;1478   		}
;;;1479   		if (OLED_IsInAngle(y, -x, StartAngle, EndAngle))
00016a  465a              MOV      r2,r11
00016c  4268              RSBS     r0,r5,#0
00016e  b201              SXTH     r1,r0
000170  4620              MOV      r0,r4
000172  9b0a              LDR      r3,[sp,#0x28]
000174  f7fffffe          BL       OLED_IsInAngle
000178  b128              CBZ      r0,|L3.390|
;;;1480   		{
;;;1481   			OLED_DrawPoint(X + y, Y - x);
00017a  1b72              SUBS     r2,r6,r5
00017c  b211              SXTH     r1,r2
00017e  193a              ADDS     r2,r7,r4
000180  b210              SXTH     r0,r2
000182  f7fffffe          BL       OLED_DrawPoint
                  |L3.390|
;;;1482   		}
;;;1483   		if (OLED_IsInAngle(-x, y, StartAngle, EndAngle))
000186  465a              MOV      r2,r11
000188  4621              MOV      r1,r4
00018a  4268              RSBS     r0,r5,#0
00018c  b200              SXTH     r0,r0
00018e  9b0a              LDR      r3,[sp,#0x28]
000190  f7fffffe          BL       OLED_IsInAngle
000194  b128              CBZ      r0,|L3.418|
;;;1484   		{
;;;1485   			OLED_DrawPoint(X - x, Y + y);
000196  1932              ADDS     r2,r6,r4
000198  b211              SXTH     r1,r2
00019a  1b7a              SUBS     r2,r7,r5
00019c  b210              SXTH     r0,r2
00019e  f7fffffe          BL       OLED_DrawPoint
                  |L3.418|
;;;1486   		}
;;;1487   		if (OLED_IsInAngle(-y, x, StartAngle, EndAngle))
0001a2  465a              MOV      r2,r11
0001a4  4629              MOV      r1,r5
0001a6  4260              RSBS     r0,r4,#0
0001a8  b200              SXTH     r0,r0
0001aa  9b0a              LDR      r3,[sp,#0x28]
0001ac  f7fffffe          BL       OLED_IsInAngle
0001b0  b128              CBZ      r0,|L3.446|
;;;1488   		{
;;;1489   			OLED_DrawPoint(X - y, Y + x);
0001b2  1972              ADDS     r2,r6,r5
0001b4  b211              SXTH     r1,r2
0001b6  1b3a              SUBS     r2,r7,r4
0001b8  b210              SXTH     r0,r2
0001ba  f7fffffe          BL       OLED_DrawPoint
                  |L3.446|
;;;1490   		}
;;;1491   
;;;1492   		if (IsFilled) // 指定圆弧填充
0001be  980b              LDR      r0,[sp,#0x2c]
0001c0  2800              CMP      r0,#0
0001c2  d04d              BEQ      |L3.608|
;;;1493   		{
;;;1494   			/*遍历中间部分*/
;;;1495   			for (j = -y; j < y; j++)
0001c4  4260              RSBS     r0,r4,#0
0001c6  fa0ff880          SXTH     r8,r0
0001ca  e020              B        |L3.526|
                  |L3.460|
;;;1496   			{
;;;1497   				/*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*/
;;;1498   				if (OLED_IsInAngle(x, j, StartAngle, EndAngle))
0001cc  465a              MOV      r2,r11
0001ce  4641              MOV      r1,r8
0001d0  4628              MOV      r0,r5
0001d2  9b0a              LDR      r3,[sp,#0x28]
0001d4  f7fffffe          BL       OLED_IsInAngle
0001d8  b130              CBZ      r0,|L3.488|
;;;1499   				{
;;;1500   					OLED_DrawPoint(X + x, Y + j);
0001da  eb060208          ADD      r2,r6,r8
0001de  b211              SXTH     r1,r2
0001e0  197a              ADDS     r2,r7,r5
0001e2  b210              SXTH     r0,r2
0001e4  f7fffffe          BL       OLED_DrawPoint
                  |L3.488|
;;;1501   				}
;;;1502   				if (OLED_IsInAngle(-x, j, StartAngle, EndAngle))
0001e8  465a              MOV      r2,r11
0001ea  4641              MOV      r1,r8
0001ec  4268              RSBS     r0,r5,#0
0001ee  b200              SXTH     r0,r0
0001f0  9b0a              LDR      r3,[sp,#0x28]
0001f2  f7fffffe          BL       OLED_IsInAngle
0001f6  b130              CBZ      r0,|L3.518|
;;;1503   				{
;;;1504   					OLED_DrawPoint(X - x, Y + j);
0001f8  eb060208          ADD      r2,r6,r8
0001fc  b211              SXTH     r1,r2
0001fe  1b7a              SUBS     r2,r7,r5
000200  b210              SXTH     r0,r2
000202  f7fffffe          BL       OLED_DrawPoint
                  |L3.518|
000206  f1080001          ADD      r0,r8,#1              ;1495
00020a  fa0ff880          SXTH     r8,r0                 ;1495
                  |L3.526|
00020e  45a0              CMP      r8,r4                 ;1495
000210  dbdc              BLT      |L3.460|
;;;1505   				}
;;;1506   			}
;;;1507   
;;;1508   			/*遍历两侧部分*/
;;;1509   			for (j = -x; j < x; j++)
000212  4268              RSBS     r0,r5,#0
000214  fa0ff880          SXTH     r8,r0
000218  e020              B        |L3.604|
                  |L3.538|
;;;1510   			{
;;;1511   				/*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*/
;;;1512   				if (OLED_IsInAngle(-y, j, StartAngle, EndAngle))
00021a  465a              MOV      r2,r11
00021c  4641              MOV      r1,r8
00021e  4260              RSBS     r0,r4,#0
000220  b200              SXTH     r0,r0
000222  9b0a              LDR      r3,[sp,#0x28]
000224  f7fffffe          BL       OLED_IsInAngle
000228  b130              CBZ      r0,|L3.568|
;;;1513   				{
;;;1514   					OLED_DrawPoint(X - y, Y + j);
00022a  eb060208          ADD      r2,r6,r8
00022e  b211              SXTH     r1,r2
000230  1b3a              SUBS     r2,r7,r4
000232  b210              SXTH     r0,r2
000234  f7fffffe          BL       OLED_DrawPoint
                  |L3.568|
;;;1515   				}
;;;1516   				if (OLED_IsInAngle(y, j, StartAngle, EndAngle))
000238  465a              MOV      r2,r11
00023a  4641              MOV      r1,r8
00023c  4620              MOV      r0,r4
00023e  9b0a              LDR      r3,[sp,#0x28]
000240  f7fffffe          BL       OLED_IsInAngle
000244  b130              CBZ      r0,|L3.596|
;;;1517   				{
;;;1518   					OLED_DrawPoint(X + y, Y + j);
000246  eb060208          ADD      r2,r6,r8
00024a  b211              SXTH     r1,r2
00024c  193a              ADDS     r2,r7,r4
00024e  b210              SXTH     r0,r2
000250  f7fffffe          BL       OLED_DrawPoint
                  |L3.596|
000254  f1080001          ADD      r0,r8,#1              ;1509
000258  fa0ff880          SXTH     r8,r0                 ;1509
                  |L3.604|
00025c  45a8              CMP      r8,r5                 ;1509
00025e  dbdc              BLT      |L3.538|
                  |L3.608|
000260  42a5              CMP      r5,r4                 ;1445
000262  f6ffaf29          BLT      |L3.184|
;;;1519   				}
;;;1520   			}
;;;1521   		}
;;;1522   	}
;;;1523   }
000266  e8bd9ff0          POP      {r4-r12,pc}
;;;1524   
                          ENDP


                          AREA ||i.OLED_DrawCircle||, CODE, READONLY, ALIGN=1

                  OLED_DrawCircle PROC
;;;1207    */
;;;1208   void OLED_DrawCircle(int16_t X, int16_t Y, uint8_t Radius, uint8_t IsFilled)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1209   {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
;;;1210   	int16_t x, y, d, j;
;;;1211   
;;;1212   	/*使用Bresenham算法画圆，可以避免耗时的浮点运算，效率更高*/
;;;1213   	/*参考文档：https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf*/
;;;1214   	/*参考教程：https://www.bilibili.com/video/BV1VM4y1u7wJ*/
;;;1215   
;;;1216   	d = 1 - Radius;
00000c  f1c90b01          RSB      r11,r9,#1
;;;1217   	x = 0;
000010  2500              MOVS     r5,#0
;;;1218   	y = Radius;
000012  464c              MOV      r4,r9
;;;1219   
;;;1220   	/*画每个八分之一圆弧的起始点*/
;;;1221   	OLED_DrawPoint(X + x, Y + y);
000014  1932              ADDS     r2,r6,r4
000016  b211              SXTH     r1,r2
000018  197a              ADDS     r2,r7,r5
00001a  b210              SXTH     r0,r2
00001c  f7fffffe          BL       OLED_DrawPoint
;;;1222   	OLED_DrawPoint(X - x, Y - y);
000020  1b32              SUBS     r2,r6,r4
000022  b211              SXTH     r1,r2
000024  1b7a              SUBS     r2,r7,r5
000026  b210              SXTH     r0,r2
000028  f7fffffe          BL       OLED_DrawPoint
;;;1223   	OLED_DrawPoint(X + y, Y + x);
00002c  1972              ADDS     r2,r6,r5
00002e  b211              SXTH     r1,r2
000030  193a              ADDS     r2,r7,r4
000032  b210              SXTH     r0,r2
000034  f7fffffe          BL       OLED_DrawPoint
;;;1224   	OLED_DrawPoint(X - y, Y - x);
000038  1b72              SUBS     r2,r6,r5
00003a  b211              SXTH     r1,r2
00003c  1b3a              SUBS     r2,r7,r4
00003e  b210              SXTH     r0,r2
000040  f7fffffe          BL       OLED_DrawPoint
;;;1225   
;;;1226   	if (IsFilled) // 指定圆填充
000044  f1ba0f00          CMP      r10,#0
000048  d00f              BEQ      |L4.106|
;;;1227   	{
;;;1228   		/*遍历起始点Y坐标*/
;;;1229   		for (j = -y; j < y; j++)
00004a  4260              RSBS     r0,r4,#0
00004c  fa0ff880          SXTH     r8,r0
000050  e009              B        |L4.102|
                  |L4.82|
;;;1230   		{
;;;1231   			/*在指定区域画点，填充部分圆*/
;;;1232   			OLED_DrawPoint(X, Y + j);
000052  eb060008          ADD      r0,r6,r8
000056  b201              SXTH     r1,r0
000058  4638              MOV      r0,r7
00005a  f7fffffe          BL       OLED_DrawPoint
00005e  f1080001          ADD      r0,r8,#1              ;1229
000062  fa0ff880          SXTH     r8,r0                 ;1229
                  |L4.102|
000066  45a0              CMP      r8,r4                 ;1229
000068  dbf3              BLT      |L4.82|
                  |L4.106|
;;;1233   		}
;;;1234   	}
;;;1235   
;;;1236   	while (x < y) // 遍历X轴的每个点
00006a  e075              B        |L4.344|
                  |L4.108|
;;;1237   	{
;;;1238   		x++;
00006c  1c68              ADDS     r0,r5,#1
00006e  b205              SXTH     r5,r0
;;;1239   		if (d < 0) // 下一个点在当前点东方
000070  f1bb0f00          CMP      r11,#0
000074  da05              BGE      |L4.130|
;;;1240   		{
;;;1241   			d += 2 * x + 1;
000076  0068              LSLS     r0,r5,#1
000078  1c40              ADDS     r0,r0,#1
00007a  4458              ADD      r0,r0,r11
00007c  fa0ffb80          SXTH     r11,r0
000080  e007              B        |L4.146|
                  |L4.130|
;;;1242   		}
;;;1243   		else // 下一个点在当前点东南方
;;;1244   		{
;;;1245   			y--;
000082  1e60              SUBS     r0,r4,#1
000084  b204              SXTH     r4,r0
;;;1246   			d += 2 * (x - y) + 1;
000086  1b28              SUBS     r0,r5,r4
000088  0040              LSLS     r0,r0,#1
00008a  1c40              ADDS     r0,r0,#1
00008c  4458              ADD      r0,r0,r11
00008e  fa0ffb80          SXTH     r11,r0
                  |L4.146|
;;;1247   		}
;;;1248   
;;;1249   		/*画每个八分之一圆弧的点*/
;;;1250   		OLED_DrawPoint(X + x, Y + y);
000092  1932              ADDS     r2,r6,r4
000094  b211              SXTH     r1,r2
000096  197a              ADDS     r2,r7,r5
000098  b210              SXTH     r0,r2
00009a  f7fffffe          BL       OLED_DrawPoint
;;;1251   		OLED_DrawPoint(X + y, Y + x);
00009e  1972              ADDS     r2,r6,r5
0000a0  b211              SXTH     r1,r2
0000a2  193a              ADDS     r2,r7,r4
0000a4  b210              SXTH     r0,r2
0000a6  f7fffffe          BL       OLED_DrawPoint
;;;1252   		OLED_DrawPoint(X - x, Y - y);
0000aa  1b32              SUBS     r2,r6,r4
0000ac  b211              SXTH     r1,r2
0000ae  1b7a              SUBS     r2,r7,r5
0000b0  b210              SXTH     r0,r2
0000b2  f7fffffe          BL       OLED_DrawPoint
;;;1253   		OLED_DrawPoint(X - y, Y - x);
0000b6  1b72              SUBS     r2,r6,r5
0000b8  b211              SXTH     r1,r2
0000ba  1b3a              SUBS     r2,r7,r4
0000bc  b210              SXTH     r0,r2
0000be  f7fffffe          BL       OLED_DrawPoint
;;;1254   		OLED_DrawPoint(X + x, Y - y);
0000c2  1b32              SUBS     r2,r6,r4
0000c4  b211              SXTH     r1,r2
0000c6  197a              ADDS     r2,r7,r5
0000c8  b210              SXTH     r0,r2
0000ca  f7fffffe          BL       OLED_DrawPoint
;;;1255   		OLED_DrawPoint(X + y, Y - x);
0000ce  1b72              SUBS     r2,r6,r5
0000d0  b211              SXTH     r1,r2
0000d2  193a              ADDS     r2,r7,r4
0000d4  b210              SXTH     r0,r2
0000d6  f7fffffe          BL       OLED_DrawPoint
;;;1256   		OLED_DrawPoint(X - x, Y + y);
0000da  1932              ADDS     r2,r6,r4
0000dc  b211              SXTH     r1,r2
0000de  1b7a              SUBS     r2,r7,r5
0000e0  b210              SXTH     r0,r2
0000e2  f7fffffe          BL       OLED_DrawPoint
;;;1257   		OLED_DrawPoint(X - y, Y + x);
0000e6  1972              ADDS     r2,r6,r5
0000e8  b211              SXTH     r1,r2
0000ea  1b3a              SUBS     r2,r7,r4
0000ec  b210              SXTH     r0,r2
0000ee  f7fffffe          BL       OLED_DrawPoint
;;;1258   
;;;1259   		if (IsFilled) // 指定圆填充
0000f2  f1ba0f00          CMP      r10,#0
0000f6  d02f              BEQ      |L4.344|
;;;1260   		{
;;;1261   			/*遍历中间部分*/
;;;1262   			for (j = -y; j < y; j++)
0000f8  4260              RSBS     r0,r4,#0
0000fa  fa0ff880          SXTH     r8,r0
0000fe  e011              B        |L4.292|
                  |L4.256|
;;;1263   			{
;;;1264   				/*在指定区域画点，填充部分圆*/
;;;1265   				OLED_DrawPoint(X + x, Y + j);
000100  eb060208          ADD      r2,r6,r8
000104  b211              SXTH     r1,r2
000106  197a              ADDS     r2,r7,r5
000108  b210              SXTH     r0,r2
00010a  f7fffffe          BL       OLED_DrawPoint
;;;1266   				OLED_DrawPoint(X - x, Y + j);
00010e  eb060208          ADD      r2,r6,r8
000112  b211              SXTH     r1,r2
000114  1b7a              SUBS     r2,r7,r5
000116  b210              SXTH     r0,r2
000118  f7fffffe          BL       OLED_DrawPoint
00011c  f1080001          ADD      r0,r8,#1              ;1262
000120  fa0ff880          SXTH     r8,r0                 ;1262
                  |L4.292|
000124  45a0              CMP      r8,r4                 ;1262
000126  dbeb              BLT      |L4.256|
;;;1267   			}
;;;1268   
;;;1269   			/*遍历两侧部分*/
;;;1270   			for (j = -x; j < x; j++)
000128  4268              RSBS     r0,r5,#0
00012a  fa0ff880          SXTH     r8,r0
00012e  e011              B        |L4.340|
                  |L4.304|
;;;1271   			{
;;;1272   				/*在指定区域画点，填充部分圆*/
;;;1273   				OLED_DrawPoint(X - y, Y + j);
000130  eb060208          ADD      r2,r6,r8
000134  b211              SXTH     r1,r2
000136  1b3a              SUBS     r2,r7,r4
000138  b210              SXTH     r0,r2
00013a  f7fffffe          BL       OLED_DrawPoint
;;;1274   				OLED_DrawPoint(X + y, Y + j);
00013e  eb060208          ADD      r2,r6,r8
000142  b211              SXTH     r1,r2
000144  193a              ADDS     r2,r7,r4
000146  b210              SXTH     r0,r2
000148  f7fffffe          BL       OLED_DrawPoint
00014c  f1080001          ADD      r0,r8,#1              ;1270
000150  fa0ff880          SXTH     r8,r0                 ;1270
                  |L4.340|
000154  45a8              CMP      r8,r5                 ;1270
000156  dbeb              BLT      |L4.304|
                  |L4.344|
000158  42a5              CMP      r5,r4                 ;1236
00015a  db87              BLT      |L4.108|
;;;1275   			}
;;;1276   		}
;;;1277   	}
;;;1278   }
00015c  e8bd8ff0          POP      {r4-r11,pc}
;;;1279   
                          ENDP


                          AREA ||i.OLED_DrawEllipse||, CODE, READONLY, ALIGN=2

                  OLED_DrawEllipse PROC
;;;1291    */
;;;1292   void OLED_DrawEllipse(int16_t X, int16_t Y, uint8_t A, uint8_t B, uint8_t IsFilled)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1293   {
000004  b097              SUB      sp,sp,#0x5c
000006  4607              MOV      r7,r0
000008  460e              MOV      r6,r1
00000a  469b              MOV      r11,r3
;;;1294   	int16_t x, y, j;
;;;1295   	int16_t a = A, b = B;
00000c  f8dda064          LDR      r10,[sp,#0x64]
000010  46d9              MOV      r9,r11
;;;1296   	float d1, d2;
;;;1297   
;;;1298   	/*使用Bresenham算法画椭圆，可以避免部分耗时的浮点运算，效率更高*/
;;;1299   	/*参考链接：https://blog.csdn.net/myf_666/article/details/128167392*/
;;;1300   
;;;1301   	x = 0;
000012  2500              MOVS     r5,#0
;;;1302   	y = b;
000014  464c              MOV      r4,r9
;;;1303   	d1 = b * b + a * a * (-b + 0.5);
000016  f1c90000          RSB      r0,r9,#0
00001a  f7fffffe          BL       __aeabi_i2d
00001e  2200              MOVS     r2,#0
000020  4bc1              LDR      r3,|L5.808|
000022  e9cd0108          STRD     r0,r1,[sp,#0x20]
000026  f7fffffe          BL       __aeabi_dadd
00002a  e9cd010c          STRD     r0,r1,[sp,#0x30]
00002e  fb0af00a          MUL      r0,r10,r10
000032  f7fffffe          BL       __aeabi_i2d
000036  e9cd010a          STRD     r0,r1,[sp,#0x28]
00003a  e9dd230c          LDRD     r2,r3,[sp,#0x30]
00003e  f7fffffe          BL       __aeabi_dmul
000042  e9cd0110          STRD     r0,r1,[sp,#0x40]
000046  fb09f009          MUL      r0,r9,r9
00004a  f7fffffe          BL       __aeabi_i2d
00004e  e9cd010e          STRD     r0,r1,[sp,#0x38]
000052  e9dd2310          LDRD     r2,r3,[sp,#0x40]
000056  f7fffffe          BL       __aeabi_dadd
00005a  e9cd0112          STRD     r0,r1,[sp,#0x48]
00005e  f7fffffe          BL       __aeabi_d2f
000062  9015              STR      r0,[sp,#0x54]
;;;1304   
;;;1305   	if (IsFilled) // 指定椭圆填充
000064  9824              LDR      r0,[sp,#0x90]
000066  b1a8              CBZ      r0,|L5.148|
;;;1306   	{
;;;1307   		/*遍历起始点Y坐标*/
;;;1308   		for (j = -y; j < y; j++)
000068  4260              RSBS     r0,r4,#0
00006a  fa0ff880          SXTH     r8,r0
00006e  e00f              B        |L5.144|
                  |L5.112|
;;;1309   		{
;;;1310   			/*在指定区域画点，填充部分椭圆*/
;;;1311   			OLED_DrawPoint(X, Y + j);
000070  eb060008          ADD      r0,r6,r8
000074  b201              SXTH     r1,r0
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       OLED_DrawPoint
;;;1312   			OLED_DrawPoint(X, Y + j);
00007c  eb060008          ADD      r0,r6,r8
000080  b201              SXTH     r1,r0
000082  4638              MOV      r0,r7
000084  f7fffffe          BL       OLED_DrawPoint
000088  f1080001          ADD      r0,r8,#1              ;1308
00008c  fa0ff880          SXTH     r8,r0                 ;1308
                  |L5.144|
000090  45a0              CMP      r8,r4                 ;1308
000092  dbed              BLT      |L5.112|
                  |L5.148|
;;;1313   		}
;;;1314   	}
;;;1315   
;;;1316   	/*画椭圆弧的起始点*/
;;;1317   	OLED_DrawPoint(X + x, Y + y);
000094  1932              ADDS     r2,r6,r4
000096  b211              SXTH     r1,r2
000098  197a              ADDS     r2,r7,r5
00009a  b210              SXTH     r0,r2
00009c  f7fffffe          BL       OLED_DrawPoint
;;;1318   	OLED_DrawPoint(X - x, Y - y);
0000a0  1b32              SUBS     r2,r6,r4
0000a2  b211              SXTH     r1,r2
0000a4  1b7a              SUBS     r2,r7,r5
0000a6  b210              SXTH     r0,r2
0000a8  f7fffffe          BL       OLED_DrawPoint
;;;1319   	OLED_DrawPoint(X - x, Y + y);
0000ac  1932              ADDS     r2,r6,r4
0000ae  b211              SXTH     r1,r2
0000b0  1b7a              SUBS     r2,r7,r5
0000b2  b210              SXTH     r0,r2
0000b4  f7fffffe          BL       OLED_DrawPoint
;;;1320   	OLED_DrawPoint(X + x, Y - y);
0000b8  1b32              SUBS     r2,r6,r4
0000ba  b211              SXTH     r1,r2
0000bc  197a              ADDS     r2,r7,r5
0000be  b210              SXTH     r0,r2
0000c0  f7fffffe          BL       OLED_DrawPoint
;;;1321   
;;;1322   	/*画椭圆中间部分*/
;;;1323   	while (b * b * (x + 1) < a * a * (y - 0.5))
0000c4  e05b              B        |L5.382|
                  |L5.198|
;;;1324   	{
;;;1325   		if (d1 <= 0) // 下一个点在当前点东方
0000c6  2100              MOVS     r1,#0
0000c8  9815              LDR      r0,[sp,#0x54]
0000ca  f7fffffe          BL       __aeabi_cfcmple
0000ce  d80d              BHI      |L5.236|
;;;1326   		{
;;;1327   			d1 += b * b * (2 * x + 3);
0000d0  fb09f109          MUL      r1,r9,r9
0000d4  006a              LSLS     r2,r5,#1
0000d6  1cd2              ADDS     r2,r2,#3
0000d8  fb01f002          MUL      r0,r1,r2
0000dc  f7fffffe          BL       __aeabi_i2f
0000e0  9013              STR      r0,[sp,#0x4c]
0000e2  9915              LDR      r1,[sp,#0x54]
0000e4  f7fffffe          BL       __aeabi_fadd
0000e8  9015              STR      r0,[sp,#0x54]
0000ea  e014              B        |L5.278|
                  |L5.236|
;;;1328   		}
;;;1329   		else // 下一个点在当前点东南方
;;;1330   		{
;;;1331   			d1 += b * b * (2 * x + 3) + a * a * (-2 * y + 2);
0000ec  fb09f109          MUL      r1,r9,r9
0000f0  006a              LSLS     r2,r5,#1
0000f2  1cd2              ADDS     r2,r2,#3
0000f4  4351              MULS     r1,r2,r1
0000f6  fb0af20a          MUL      r2,r10,r10
0000fa  0063              LSLS     r3,r4,#1
0000fc  f1c30302          RSB      r3,r3,#2
000100  fb021003          MLA      r0,r2,r3,r1
000104  f7fffffe          BL       __aeabi_i2f
000108  9013              STR      r0,[sp,#0x4c]
00010a  9915              LDR      r1,[sp,#0x54]
00010c  f7fffffe          BL       __aeabi_fadd
000110  9015              STR      r0,[sp,#0x54]
;;;1332   			y--;
000112  1e60              SUBS     r0,r4,#1
000114  b204              SXTH     r4,r0
                  |L5.278|
;;;1333   		}
;;;1334   		x++;
000116  1c68              ADDS     r0,r5,#1
000118  b205              SXTH     r5,r0
;;;1335   
;;;1336   		if (IsFilled) // 指定椭圆填充
00011a  9824              LDR      r0,[sp,#0x90]
00011c  b1b8              CBZ      r0,|L5.334|
;;;1337   		{
;;;1338   			/*遍历中间部分*/
;;;1339   			for (j = -y; j < y; j++)
00011e  4260              RSBS     r0,r4,#0
000120  fa0ff880          SXTH     r8,r0
000124  e011              B        |L5.330|
                  |L5.294|
;;;1340   			{
;;;1341   				/*在指定区域画点，填充部分椭圆*/
;;;1342   				OLED_DrawPoint(X + x, Y + j);
000126  eb060208          ADD      r2,r6,r8
00012a  b211              SXTH     r1,r2
00012c  197a              ADDS     r2,r7,r5
00012e  b210              SXTH     r0,r2
000130  f7fffffe          BL       OLED_DrawPoint
;;;1343   				OLED_DrawPoint(X - x, Y + j);
000134  eb060208          ADD      r2,r6,r8
000138  b211              SXTH     r1,r2
00013a  1b7a              SUBS     r2,r7,r5
00013c  b210              SXTH     r0,r2
00013e  f7fffffe          BL       OLED_DrawPoint
000142  f1080001          ADD      r0,r8,#1              ;1339
000146  fa0ff880          SXTH     r8,r0                 ;1339
                  |L5.330|
00014a  45a0              CMP      r8,r4                 ;1339
00014c  dbeb              BLT      |L5.294|
                  |L5.334|
;;;1344   			}
;;;1345   		}
;;;1346   
;;;1347   		/*画椭圆中间部分圆弧*/
;;;1348   		OLED_DrawPoint(X + x, Y + y);
00014e  1932              ADDS     r2,r6,r4
000150  b211              SXTH     r1,r2
000152  197a              ADDS     r2,r7,r5
000154  b210              SXTH     r0,r2
000156  f7fffffe          BL       OLED_DrawPoint
;;;1349   		OLED_DrawPoint(X - x, Y - y);
00015a  1b32              SUBS     r2,r6,r4
00015c  b211              SXTH     r1,r2
00015e  1b7a              SUBS     r2,r7,r5
000160  b210              SXTH     r0,r2
000162  f7fffffe          BL       OLED_DrawPoint
;;;1350   		OLED_DrawPoint(X - x, Y + y);
000166  1932              ADDS     r2,r6,r4
000168  b211              SXTH     r1,r2
00016a  1b7a              SUBS     r2,r7,r5
00016c  b210              SXTH     r0,r2
00016e  f7fffffe          BL       OLED_DrawPoint
;;;1351   		OLED_DrawPoint(X + x, Y - y);
000172  1b32              SUBS     r2,r6,r4
000174  b211              SXTH     r1,r2
000176  197a              ADDS     r2,r7,r5
000178  b210              SXTH     r0,r2
00017a  f7fffffe          BL       OLED_DrawPoint
                  |L5.382|
00017e  4620              MOV      r0,r4                 ;1323
000180  f7fffffe          BL       __aeabi_i2d
000184  2200              MOVS     r2,#0                 ;1323
000186  4b68              LDR      r3,|L5.808|
000188  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;1323
00018c  f7fffffe          BL       __aeabi_dsub
000190  e9cd010e          STRD     r0,r1,[sp,#0x38]      ;1323
000194  fb0af00a          MUL      r0,r10,r10            ;1323
000198  f7fffffe          BL       __aeabi_i2d
00019c  e9cd010c          STRD     r0,r1,[sp,#0x30]      ;1323
0001a0  e9dd230e          LDRD     r2,r3,[sp,#0x38]      ;1323
0001a4  f7fffffe          BL       __aeabi_dmul
0001a8  e9cd0112          STRD     r0,r1,[sp,#0x48]      ;1323
0001ac  fb09f109          MUL      r1,r9,r9              ;1323
0001b0  1c6a              ADDS     r2,r5,#1              ;1323
0001b2  fb01f002          MUL      r0,r1,r2              ;1323
0001b6  f7fffffe          BL       __aeabi_i2d
0001ba  e9cd0110          STRD     r0,r1,[sp,#0x40]      ;1323
0001be  e9dd2312          LDRD     r2,r3,[sp,#0x48]      ;1323
0001c2  f7fffffe          BL       __aeabi_cdcmple
0001c6  f4ffaf7e          BCC      |L5.198|
;;;1352   	}
;;;1353   
;;;1354   	/*画椭圆两侧部分*/
;;;1355   	d2 = b * b * (x + 0.5) * (x + 0.5) + a * a * (y - 1) * (y - 1) - a * a * b * b;
0001ca  fb0af10a          MUL      r1,r10,r10
0001ce  fb01f109          MUL      r1,r1,r9
0001d2  fb01f009          MUL      r0,r1,r9
0001d6  f7fffffe          BL       __aeabi_i2d
0001da  e9cd0110          STRD     r0,r1,[sp,#0x40]
0001de  fb0af10a          MUL      r1,r10,r10
0001e2  1e62              SUBS     r2,r4,#1
0001e4  4351              MULS     r1,r2,r1
0001e6  fb01f002          MUL      r0,r1,r2
0001ea  f7fffffe          BL       __aeabi_i2d
0001ee  e9cd010c          STRD     r0,r1,[sp,#0x30]
0001f2  4628              MOV      r0,r5
0001f4  f7fffffe          BL       __aeabi_i2d
0001f8  2200              MOVS     r2,#0
0001fa  4b4b              LDR      r3,|L5.808|
0001fc  e9cd0104          STRD     r0,r1,[sp,#0x10]
000200  f7fffffe          BL       __aeabi_dadd
000204  e9cd0108          STRD     r0,r1,[sp,#0x20]
000208  4628              MOV      r0,r5
00020a  f7fffffe          BL       __aeabi_i2d
00020e  2200              MOVS     r2,#0
000210  4b45              LDR      r3,|L5.808|
000212  e9cd0100          STRD     r0,r1,[sp,#0]
000216  f7fffffe          BL       __aeabi_dadd
00021a  e9cd0104          STRD     r0,r1,[sp,#0x10]
00021e  fb09f009          MUL      r0,r9,r9
000222  f7fffffe          BL       __aeabi_i2d
000226  e9cd0102          STRD     r0,r1,[sp,#8]
00022a  e9dd2304          LDRD     r2,r3,[sp,#0x10]
00022e  f7fffffe          BL       __aeabi_dmul
000232  e9cd0106          STRD     r0,r1,[sp,#0x18]
000236  e9dd2308          LDRD     r2,r3,[sp,#0x20]
00023a  f7fffffe          BL       __aeabi_dmul
00023e  e9cd010a          STRD     r0,r1,[sp,#0x28]
000242  e9dd230c          LDRD     r2,r3,[sp,#0x30]
000246  f7fffffe          BL       __aeabi_dadd
00024a  e9cd010e          STRD     r0,r1,[sp,#0x38]
00024e  e9dd2310          LDRD     r2,r3,[sp,#0x40]
000252  f7fffffe          BL       __aeabi_dsub
000256  e9cd0112          STRD     r0,r1,[sp,#0x48]
00025a  f7fffffe          BL       __aeabi_d2f
00025e  9014              STR      r0,[sp,#0x50]
;;;1356   
;;;1357   	while (y > 0)
000260  e05c              B        |L5.796|
                  |L5.610|
;;;1358   	{
;;;1359   		if (d2 <= 0) // 下一个点在当前点东方
000262  2100              MOVS     r1,#0
000264  9814              LDR      r0,[sp,#0x50]
000266  f7fffffe          BL       __aeabi_cfcmple
00026a  d815              BHI      |L5.664|
;;;1360   		{
;;;1361   			d2 += b * b * (2 * x + 2) + a * a * (-2 * y + 3);
00026c  fb09f109          MUL      r1,r9,r9
000270  006a              LSLS     r2,r5,#1
000272  1c92              ADDS     r2,r2,#2
000274  4351              MULS     r1,r2,r1
000276  fb0af20a          MUL      r2,r10,r10
00027a  0063              LSLS     r3,r4,#1
00027c  f1c30303          RSB      r3,r3,#3
000280  fb021003          MLA      r0,r2,r3,r1
000284  f7fffffe          BL       __aeabi_i2f
000288  9013              STR      r0,[sp,#0x4c]
00028a  9914              LDR      r1,[sp,#0x50]
00028c  f7fffffe          BL       __aeabi_fadd
000290  9014              STR      r0,[sp,#0x50]
;;;1362   			x++;
000292  1c68              ADDS     r0,r5,#1
000294  b205              SXTH     r5,r0
000296  e00d              B        |L5.692|
                  |L5.664|
;;;1363   		}
;;;1364   		else // 下一个点在当前点东南方
;;;1365   		{
;;;1366   			d2 += a * a * (-2 * y + 3);
000298  fb0af10a          MUL      r1,r10,r10
00029c  0062              LSLS     r2,r4,#1
00029e  f1c20203          RSB      r2,r2,#3
0002a2  fb01f002          MUL      r0,r1,r2
0002a6  f7fffffe          BL       __aeabi_i2f
0002aa  9013              STR      r0,[sp,#0x4c]
0002ac  9914              LDR      r1,[sp,#0x50]
0002ae  f7fffffe          BL       __aeabi_fadd
0002b2  9014              STR      r0,[sp,#0x50]
                  |L5.692|
;;;1367   		}
;;;1368   		y--;
0002b4  1e60              SUBS     r0,r4,#1
0002b6  b204              SXTH     r4,r0
;;;1369   
;;;1370   		if (IsFilled) // 指定椭圆填充
0002b8  9824              LDR      r0,[sp,#0x90]
0002ba  b1b8              CBZ      r0,|L5.748|
;;;1371   		{
;;;1372   			/*遍历两侧部分*/
;;;1373   			for (j = -y; j < y; j++)
0002bc  4260              RSBS     r0,r4,#0
0002be  fa0ff880          SXTH     r8,r0
0002c2  e011              B        |L5.744|
                  |L5.708|
;;;1374   			{
;;;1375   				/*在指定区域画点，填充部分椭圆*/
;;;1376   				OLED_DrawPoint(X + x, Y + j);
0002c4  eb060208          ADD      r2,r6,r8
0002c8  b211              SXTH     r1,r2
0002ca  197a              ADDS     r2,r7,r5
0002cc  b210              SXTH     r0,r2
0002ce  f7fffffe          BL       OLED_DrawPoint
;;;1377   				OLED_DrawPoint(X - x, Y + j);
0002d2  eb060208          ADD      r2,r6,r8
0002d6  b211              SXTH     r1,r2
0002d8  1b7a              SUBS     r2,r7,r5
0002da  b210              SXTH     r0,r2
0002dc  f7fffffe          BL       OLED_DrawPoint
0002e0  f1080001          ADD      r0,r8,#1              ;1373
0002e4  fa0ff880          SXTH     r8,r0                 ;1373
                  |L5.744|
0002e8  45a0              CMP      r8,r4                 ;1373
0002ea  dbeb              BLT      |L5.708|
                  |L5.748|
;;;1378   			}
;;;1379   		}
;;;1380   
;;;1381   		/*画椭圆两侧部分圆弧*/
;;;1382   		OLED_DrawPoint(X + x, Y + y);
0002ec  1932              ADDS     r2,r6,r4
0002ee  b211              SXTH     r1,r2
0002f0  197a              ADDS     r2,r7,r5
0002f2  b210              SXTH     r0,r2
0002f4  f7fffffe          BL       OLED_DrawPoint
;;;1383   		OLED_DrawPoint(X - x, Y - y);
0002f8  1b32              SUBS     r2,r6,r4
0002fa  b211              SXTH     r1,r2
0002fc  1b7a              SUBS     r2,r7,r5
0002fe  b210              SXTH     r0,r2
000300  f7fffffe          BL       OLED_DrawPoint
;;;1384   		OLED_DrawPoint(X - x, Y + y);
000304  1932              ADDS     r2,r6,r4
000306  b211              SXTH     r1,r2
000308  1b7a              SUBS     r2,r7,r5
00030a  b210              SXTH     r0,r2
00030c  f7fffffe          BL       OLED_DrawPoint
;;;1385   		OLED_DrawPoint(X + x, Y - y);
000310  1b32              SUBS     r2,r6,r4
000312  b211              SXTH     r1,r2
000314  197a              ADDS     r2,r7,r5
000316  b210              SXTH     r0,r2
000318  f7fffffe          BL       OLED_DrawPoint
                  |L5.796|
00031c  2c00              CMP      r4,#0                 ;1357
00031e  dca0              BGT      |L5.610|
;;;1386   	}
;;;1387   }
000320  b01b              ADD      sp,sp,#0x6c
000322  e8bd8ff0          POP      {r4-r11,pc}
;;;1388   
                          ENDP

000326  0000              DCW      0x0000
                  |L5.808|
                          DCD      0x3fe00000

                          AREA ||i.OLED_DrawLine||, CODE, READONLY, ALIGN=1

                  OLED_DrawLine PROC
;;;922     */
;;;923    void OLED_DrawLine(int16_t X0, int16_t Y0, int16_t X1, int16_t Y1)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;924    {
000004  b086              SUB      sp,sp,#0x18
;;;925    	int16_t x, y, dx, dy, d, incrE, incrNE, temp;
;;;926    	int16_t x0 = X0, y0 = Y0, x1 = X1, y1 = Y1;
000006  9e06              LDR      r6,[sp,#0x18]
000008  9c07              LDR      r4,[sp,#0x1c]
00000a  f8dd8020          LDR      r8,[sp,#0x20]
00000e  f8dd9024          LDR      r9,[sp,#0x24]
;;;927    	uint8_t yflag = 0, xyflag = 0;
000012  2000              MOVS     r0,#0
000014  9001              STR      r0,[sp,#4]
000016  9000              STR      r0,[sp,#0]
;;;928    
;;;929    	if (y0 == y1) // 横线单独处理
000018  454c              CMP      r4,r9
00001a  d10f              BNE      |L6.60|
;;;930    	{
;;;931    		/*0号点X坐标大于1号点X坐标，则交换两点X坐标*/
;;;932    		if (x0 > x1)
00001c  4546              CMP      r6,r8
00001e  dd02              BLE      |L6.38|
;;;933    		{
;;;934    			temp = x0;
000020  46b2              MOV      r10,r6
;;;935    			x0 = x1;
000022  4646              MOV      r6,r8
;;;936    			x1 = temp;
000024  46d0              MOV      r8,r10
                  |L6.38|
;;;937    		}
;;;938    
;;;939    		/*遍历X坐标*/
;;;940    		for (x = x0; x <= x1; x++)
000026  4635              MOV      r5,r6
000028  e005              B        |L6.54|
                  |L6.42|
;;;941    		{
;;;942    			OLED_DrawPoint(x, y0); // 依次画点
00002a  4621              MOV      r1,r4
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       OLED_DrawPoint
000032  1c68              ADDS     r0,r5,#1              ;940
000034  b205              SXTH     r5,r0                 ;940
                  |L6.54|
000036  4545              CMP      r5,r8                 ;940
000038  ddf7              BLE      |L6.42|
00003a  e099              B        |L6.368|
                  |L6.60|
;;;943    		}
;;;944    	}
;;;945    	else if (x0 == x1) // 竖线单独处理
00003c  4546              CMP      r6,r8
00003e  d10f              BNE      |L6.96|
;;;946    	{
;;;947    		/*0号点Y坐标大于1号点Y坐标，则交换两点Y坐标*/
;;;948    		if (y0 > y1)
000040  454c              CMP      r4,r9
000042  dd02              BLE      |L6.74|
;;;949    		{
;;;950    			temp = y0;
000044  46a2              MOV      r10,r4
;;;951    			y0 = y1;
000046  464c              MOV      r4,r9
;;;952    			y1 = temp;
000048  46d1              MOV      r9,r10
                  |L6.74|
;;;953    		}
;;;954    
;;;955    		/*遍历Y坐标*/
;;;956    		for (y = y0; y <= y1; y++)
00004a  4627              MOV      r7,r4
00004c  e005              B        |L6.90|
                  |L6.78|
;;;957    		{
;;;958    			OLED_DrawPoint(x0, y); // 依次画点
00004e  4639              MOV      r1,r7
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       OLED_DrawPoint
000056  1c78              ADDS     r0,r7,#1              ;956
000058  b207              SXTH     r7,r0                 ;956
                  |L6.90|
00005a  454f              CMP      r7,r9                 ;956
00005c  ddf7              BLE      |L6.78|
00005e  e087              B        |L6.368|
                  |L6.96|
;;;959    		}
;;;960    	}
;;;961    	else // 斜线
;;;962    	{
;;;963    		/*使用Bresenham算法画直线，可以避免耗时的浮点运算，效率更高*/
;;;964    		/*参考文档：https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf*/
;;;965    		/*参考教程：https://www.bilibili.com/video/BV1364y1d7Lo*/
;;;966    
;;;967    		if (x0 > x1) // 0号点X坐标大于1号点X坐标
000060  4546              CMP      r6,r8
000062  dd05              BLE      |L6.112|
;;;968    		{
;;;969    			/*交换两点坐标*/
;;;970    			/*交换后不影响画线，但是画线方向由第一、二、三、四象限变为第一、四象限*/
;;;971    			temp = x0;
000064  46b2              MOV      r10,r6
;;;972    			x0 = x1;
000066  4646              MOV      r6,r8
;;;973    			x1 = temp;
000068  46d0              MOV      r8,r10
;;;974    			temp = y0;
00006a  46a2              MOV      r10,r4
;;;975    			y0 = y1;
00006c  464c              MOV      r4,r9
;;;976    			y1 = temp;
00006e  46d1              MOV      r9,r10
                  |L6.112|
;;;977    		}
;;;978    
;;;979    		if (y0 > y1) // 0号点Y坐标大于1号点Y坐标
000070  454c              CMP      r4,r9
000072  dd07              BLE      |L6.132|
;;;980    		{
;;;981    			/*将Y坐标取负*/
;;;982    			/*取负后影响画线，但是画线方向由第一、四象限变为第一象限*/
;;;983    			y0 = -y0;
000074  4260              RSBS     r0,r4,#0
000076  b204              SXTH     r4,r0
;;;984    			y1 = -y1;
000078  f1c90000          RSB      r0,r9,#0
00007c  fa0ff980          SXTH     r9,r0
;;;985    
;;;986    			/*置标志位yflag，记住当前变换，在后续实际画线时，再将坐标换回来*/
;;;987    			yflag = 1;
000080  2001              MOVS     r0,#1
000082  9001              STR      r0,[sp,#4]
                  |L6.132|
;;;988    		}
;;;989    
;;;990    		if (y1 - y0 > x1 - x0) // 画线斜率大于1
000084  eba90004          SUB      r0,r9,r4
000088  eba80106          SUB      r1,r8,r6
00008c  4288              CMP      r0,r1
00008e  dd07              BLE      |L6.160|
;;;991    		{
;;;992    			/*将X坐标与Y坐标互换*/
;;;993    			/*互换后影响画线，但是画线方向由第一象限0~90度范围变为第一象限0~45度范围*/
;;;994    			temp = x0;
000090  46b2              MOV      r10,r6
;;;995    			x0 = y0;
000092  4626              MOV      r6,r4
;;;996    			y0 = temp;
000094  4654              MOV      r4,r10
;;;997    			temp = x1;
000096  46c2              MOV      r10,r8
;;;998    			x1 = y1;
000098  46c8              MOV      r8,r9
;;;999    			y1 = temp;
00009a  46d1              MOV      r9,r10
;;;1000   
;;;1001   			/*置标志位xyflag，记住当前变换，在后续实际画线时，再将坐标换回来*/
;;;1002   			xyflag = 1;
00009c  2001              MOVS     r0,#1
00009e  9000              STR      r0,[sp,#0]
                  |L6.160|
;;;1003   		}
;;;1004   
;;;1005   		/*以下为Bresenham算法画直线*/
;;;1006   		/*算法要求，画线方向必须为第一象限0~45度范围*/
;;;1007   		dx = x1 - x0;
0000a0  eba80006          SUB      r0,r8,r6
0000a4  b200              SXTH     r0,r0
0000a6  9005              STR      r0,[sp,#0x14]
;;;1008   		dy = y1 - y0;
0000a8  eba90004          SUB      r0,r9,r4
0000ac  fa0ffb80          SXTH     r11,r0
;;;1009   		incrE = 2 * dy;
0000b0  ea4f004b          LSL      r0,r11,#1
0000b4  b200              SXTH     r0,r0
0000b6  9003              STR      r0,[sp,#0xc]
;;;1010   		incrNE = 2 * (dy - dx);
0000b8  9805              LDR      r0,[sp,#0x14]
0000ba  ebab0000          SUB      r0,r11,r0
0000be  0040              LSLS     r0,r0,#1
0000c0  b200              SXTH     r0,r0
0000c2  9002              STR      r0,[sp,#8]
;;;1011   		d = 2 * dy - dx;
0000c4  9805              LDR      r0,[sp,#0x14]
0000c6  ebc0004b          RSB      r0,r0,r11,LSL #1
0000ca  b200              SXTH     r0,r0
0000cc  9004              STR      r0,[sp,#0x10]
;;;1012   		x = x0;
0000ce  4635              MOV      r5,r6
;;;1013   		y = y0;
0000d0  4627              MOV      r7,r4
;;;1014   
;;;1015   		/*画起始点，同时判断标志位，将坐标换回来*/
;;;1016   		if (yflag && xyflag)
0000d2  9801              LDR      r0,[sp,#4]
0000d4  b138              CBZ      r0,|L6.230|
0000d6  9800              LDR      r0,[sp,#0]
0000d8  b128              CBZ      r0,|L6.230|
;;;1017   		{
;;;1018   			OLED_DrawPoint(y, -x);
0000da  4268              RSBS     r0,r5,#0
0000dc  b201              SXTH     r1,r0
0000de  4638              MOV      r0,r7
0000e0  f7fffffe          BL       OLED_DrawPoint
0000e4  e012              B        |L6.268|
                  |L6.230|
;;;1019   		}
;;;1020   		else if (yflag)
0000e6  9801              LDR      r0,[sp,#4]
0000e8  b128              CBZ      r0,|L6.246|
;;;1021   		{
;;;1022   			OLED_DrawPoint(x, -y);
0000ea  4278              RSBS     r0,r7,#0
0000ec  b201              SXTH     r1,r0
0000ee  4628              MOV      r0,r5
0000f0  f7fffffe          BL       OLED_DrawPoint
0000f4  e00a              B        |L6.268|
                  |L6.246|
;;;1023   		}
;;;1024   		else if (xyflag)
0000f6  9800              LDR      r0,[sp,#0]
0000f8  b120              CBZ      r0,|L6.260|
;;;1025   		{
;;;1026   			OLED_DrawPoint(y, x);
0000fa  4629              MOV      r1,r5
0000fc  4638              MOV      r0,r7
0000fe  f7fffffe          BL       OLED_DrawPoint
000102  e003              B        |L6.268|
                  |L6.260|
;;;1027   		}
;;;1028   		else
;;;1029   		{
;;;1030   			OLED_DrawPoint(x, y);
000104  4639              MOV      r1,r7
000106  4628              MOV      r0,r5
000108  f7fffffe          BL       OLED_DrawPoint
                  |L6.268|
;;;1031   		}
;;;1032   
;;;1033   		while (x < x1) // 遍历X轴的每个点
00010c  e02e              B        |L6.364|
                  |L6.270|
;;;1034   		{
;;;1035   			x++;
00010e  1c68              ADDS     r0,r5,#1
000110  b205              SXTH     r5,r0
;;;1036   			if (d < 0) // 下一个点在当前点东方
000112  9804              LDR      r0,[sp,#0x10]
000114  2800              CMP      r0,#0
000116  da05              BGE      |L6.292|
;;;1037   			{
;;;1038   				d += incrE;
000118  e9dd1003          LDRD     r1,r0,[sp,#0xc]
00011c  4408              ADD      r0,r0,r1
00011e  b200              SXTH     r0,r0
000120  9004              STR      r0,[sp,#0x10]
000122  e006              B        |L6.306|
                  |L6.292|
;;;1039   			}
;;;1040   			else // 下一个点在当前点东北方
;;;1041   			{
;;;1042   				y++;
000124  1c78              ADDS     r0,r7,#1
000126  b207              SXTH     r7,r0
;;;1043   				d += incrNE;
000128  9902              LDR      r1,[sp,#8]
00012a  9804              LDR      r0,[sp,#0x10]
00012c  4408              ADD      r0,r0,r1
00012e  b200              SXTH     r0,r0
000130  9004              STR      r0,[sp,#0x10]
                  |L6.306|
;;;1044   			}
;;;1045   
;;;1046   			/*画每一个点，同时判断标志位，将坐标换回来*/
;;;1047   			if (yflag && xyflag)
000132  9801              LDR      r0,[sp,#4]
000134  b138              CBZ      r0,|L6.326|
000136  9800              LDR      r0,[sp,#0]
000138  b128              CBZ      r0,|L6.326|
;;;1048   			{
;;;1049   				OLED_DrawPoint(y, -x);
00013a  4268              RSBS     r0,r5,#0
00013c  b201              SXTH     r1,r0
00013e  4638              MOV      r0,r7
000140  f7fffffe          BL       OLED_DrawPoint
000144  e012              B        |L6.364|
                  |L6.326|
;;;1050   			}
;;;1051   			else if (yflag)
000146  9801              LDR      r0,[sp,#4]
000148  b128              CBZ      r0,|L6.342|
;;;1052   			{
;;;1053   				OLED_DrawPoint(x, -y);
00014a  4278              RSBS     r0,r7,#0
00014c  b201              SXTH     r1,r0
00014e  4628              MOV      r0,r5
000150  f7fffffe          BL       OLED_DrawPoint
000154  e00a              B        |L6.364|
                  |L6.342|
;;;1054   			}
;;;1055   			else if (xyflag)
000156  9800              LDR      r0,[sp,#0]
000158  b120              CBZ      r0,|L6.356|
;;;1056   			{
;;;1057   				OLED_DrawPoint(y, x);
00015a  4629              MOV      r1,r5
00015c  4638              MOV      r0,r7
00015e  f7fffffe          BL       OLED_DrawPoint
000162  e003              B        |L6.364|
                  |L6.356|
;;;1058   			}
;;;1059   			else
;;;1060   			{
;;;1061   				OLED_DrawPoint(x, y);
000164  4639              MOV      r1,r7
000166  4628              MOV      r0,r5
000168  f7fffffe          BL       OLED_DrawPoint
                  |L6.364|
00016c  4545              CMP      r5,r8                 ;1033
00016e  dbce              BLT      |L6.270|
                  |L6.368|
;;;1062   			}
;;;1063   		}
;;;1064   	}
;;;1065   }
000170  b00a              ADD      sp,sp,#0x28
000172  e8bd8ff0          POP      {r4-r11,pc}
;;;1066   
                          ENDP


                          AREA ||i.OLED_DrawPoint||, CODE, READONLY, ALIGN=2

                  OLED_DrawPoint PROC
;;;884     */
;;;885    void OLED_DrawPoint(int16_t X, int16_t Y)
000000  b570              PUSH     {r4-r6,lr}
;;;886    {
000002  4603              MOV      r3,r0
;;;887    	if (X >= 0 && X <= 127 && Y >= 0 && Y <= 63) // 超出屏幕的内容不显示
000004  2b00              CMP      r3,#0
000006  db20              BLT      |L7.74|
000008  2b7f              CMP      r3,#0x7f
00000a  dc1e              BGT      |L7.74|
00000c  2900              CMP      r1,#0
00000e  db1c              BLT      |L7.74|
000010  293f              CMP      r1,#0x3f
000012  dc1a              BGT      |L7.74|
;;;888    	{
;;;889    		/*将显存数组指定位置的一个Bit数据置1*/
;;;890    		OLED_DisplayBuf[Y / 8][X] |= 0x01 << (Y % 8);
000014  17cc              ASRS     r4,r1,#31
000016  eb017454          ADD      r4,r1,r4,LSR #29
00001a  10e4              ASRS     r4,r4,#3
00001c  4d0b              LDR      r5,|L7.76|
00001e  eb0514c4          ADD      r4,r5,r4,LSL #7
000022  5ce4              LDRB     r4,[r4,r3]
000024  460a              MOV      r2,r1
000026  17cd              ASRS     r5,r1,#31
000028  eb017555          ADD      r5,r1,r5,LSR #29
00002c  10ed              ASRS     r5,r5,#3
00002e  eba106c5          SUB      r6,r1,r5,LSL #3
000032  2501              MOVS     r5,#1
000034  40b5              LSLS     r5,r5,r6
000036  432c              ORRS     r4,r4,r5
000038  4608              MOV      r0,r1
00003a  17cd              ASRS     r5,r1,#31
00003c  eb017555          ADD      r5,r1,r5,LSR #29
000040  10ed              ASRS     r5,r5,#3
000042  4e02              LDR      r6,|L7.76|
000044  eb0615c5          ADD      r5,r6,r5,LSL #7
000048  54ec              STRB     r4,[r5,r3]
                  |L7.74|
;;;891    	}
;;;892    }
00004a  bd70              POP      {r4-r6,pc}
;;;893    
                          ENDP

                  |L7.76|
                          DCD      OLED_DisplayBuf

                          AREA ||i.OLED_DrawRectangle||, CODE, READONLY, ALIGN=1

                  OLED_DrawRectangle PROC
;;;1078    */
;;;1079   void OLED_DrawRectangle(int16_t X, int16_t Y, uint8_t Width, uint8_t Height, uint8_t IsFilled)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1080   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dda020          LDR      r10,[sp,#0x20]
;;;1081   	int16_t i, j;
;;;1082   	if (!IsFilled) // 指定矩形不填充
000010  f1ba0f00          CMP      r10,#0
000014  d124              BNE      |L8.96|
;;;1083   	{
;;;1084   		/*遍历上下X坐标，画矩形上下两条线*/
;;;1085   		for (i = X; i < X + Width; i++)
000016  462c              MOV      r4,r5
000018  e00c              B        |L8.52|
                  |L8.26|
;;;1086   		{
;;;1087   			OLED_DrawPoint(i, Y);
00001a  4631              MOV      r1,r6
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       OLED_DrawPoint
;;;1088   			OLED_DrawPoint(i, Y + Height - 1);
000022  eb060008          ADD      r0,r6,r8
000026  1e40              SUBS     r0,r0,#1
000028  b201              SXTH     r1,r0
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       OLED_DrawPoint
000030  1c60              ADDS     r0,r4,#1              ;1085
000032  b204              SXTH     r4,r0                 ;1085
                  |L8.52|
000034  19e8              ADDS     r0,r5,r7              ;1085
000036  42a0              CMP      r0,r4                 ;1085
000038  dcef              BGT      |L8.26|
;;;1089   		}
;;;1090   		/*遍历左右Y坐标，画矩形左右两条线*/
;;;1091   		for (i = Y; i < Y + Height; i++)
00003a  4634              MOV      r4,r6
00003c  e00b              B        |L8.86|
                  |L8.62|
;;;1092   		{
;;;1093   			OLED_DrawPoint(X, i);
00003e  4621              MOV      r1,r4
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       OLED_DrawPoint
;;;1094   			OLED_DrawPoint(X + Width - 1, i);
000046  19e9              ADDS     r1,r5,r7
000048  1e49              SUBS     r1,r1,#1
00004a  b208              SXTH     r0,r1
00004c  4621              MOV      r1,r4
00004e  f7fffffe          BL       OLED_DrawPoint
000052  1c60              ADDS     r0,r4,#1              ;1091
000054  b204              SXTH     r4,r0                 ;1091
                  |L8.86|
000056  eb060008          ADD      r0,r6,r8              ;1091
00005a  42a0              CMP      r0,r4                 ;1091
00005c  dcef              BGT      |L8.62|
00005e  e014              B        |L8.138|
                  |L8.96|
;;;1095   		}
;;;1096   	}
;;;1097   	else // 指定矩形填充
;;;1098   	{
;;;1099   		/*遍历X坐标*/
;;;1100   		for (i = X; i < X + Width; i++)
000060  462c              MOV      r4,r5
000062  e00f              B        |L8.132|
                  |L8.100|
;;;1101   		{
;;;1102   			/*遍历Y坐标*/
;;;1103   			for (j = Y; j < Y + Height; j++)
000064  46b1              MOV      r9,r6
000066  e007              B        |L8.120|
                  |L8.104|
;;;1104   			{
;;;1105   				/*在指定区域画点，填充满矩形*/
;;;1106   				OLED_DrawPoint(i, j);
000068  4649              MOV      r1,r9
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       OLED_DrawPoint
000070  f1090001          ADD      r0,r9,#1              ;1103
000074  fa0ff980          SXTH     r9,r0                 ;1103
                  |L8.120|
000078  eb060008          ADD      r0,r6,r8              ;1103
00007c  4548              CMP      r0,r9                 ;1103
00007e  dcf3              BGT      |L8.104|
000080  1c60              ADDS     r0,r4,#1              ;1100
000082  b204              SXTH     r4,r0                 ;1100
                  |L8.132|
000084  19e8              ADDS     r0,r5,r7              ;1100
000086  42a0              CMP      r0,r4                 ;1100
000088  dcec              BGT      |L8.100|
                  |L8.138|
;;;1107   			}
;;;1108   		}
;;;1109   	}
;;;1110   }
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;1111   
                          ENDP


                          AREA ||i.OLED_DrawTriangle||, CODE, READONLY, ALIGN=1

                  OLED_DrawTriangle PROC
;;;1125    */
;;;1126   void OLED_DrawTriangle(int16_t X0, int16_t Y0, int16_t X1, int16_t Y1, int16_t X2, int16_t Y2, uint8_t IsFilled)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1127   {
000004  b087              SUB      sp,sp,#0x1c
000006  4614              MOV      r4,r2
000008  461d              MOV      r5,r3
00000a  e9dd6714          LDRD     r6,r7,[sp,#0x50]
;;;1128   	int16_t minx = X0, miny = Y0, maxx = X0, maxy = Y0;
00000e  f8dd801c          LDR      r8,[sp,#0x1c]
000012  f8dd9020          LDR      r9,[sp,#0x20]
000016  f8dd801c          LDR      r8,[sp,#0x1c]
00001a  f8cd8018          STR      r8,[sp,#0x18]
00001e  f8dd9020          LDR      r9,[sp,#0x20]
000022  46cb              MOV      r11,r9
;;;1129   	int16_t i, j;
;;;1130   	int16_t vx[] = {X0, X1, X2};
000024  f8dd801c          LDR      r8,[sp,#0x1c]
000028  f8ad800c          STRH     r8,[sp,#0xc]
00002c  f8ad400e          STRH     r4,[sp,#0xe]
000030  f8ad6010          STRH     r6,[sp,#0x10]
;;;1131   	int16_t vy[] = {Y0, Y1, Y2};
000034  f8dd9020          LDR      r9,[sp,#0x20]
000038  f8ad9004          STRH     r9,[sp,#4]
00003c  f8ad5006          STRH     r5,[sp,#6]
000040  f8ad7008          STRH     r7,[sp,#8]
;;;1132   
;;;1133   	if (!IsFilled) // 指定三角形不填充
000044  9816              LDR      r0,[sp,#0x58]
000046  b990              CBNZ     r0,|L9.110|
;;;1134   	{
;;;1135   		/*调用画线函数，将三个点用直线连接*/
;;;1136   		OLED_DrawLine(X0, Y0, X1, Y1);
000048  462b              MOV      r3,r5
00004a  4622              MOV      r2,r4
00004c  e9dd0107          LDRD     r0,r1,[sp,#0x1c]
000050  f7fffffe          BL       OLED_DrawLine
;;;1137   		OLED_DrawLine(X0, Y0, X2, Y2);
000054  463b              MOV      r3,r7
000056  4632              MOV      r2,r6
000058  e9dd0107          LDRD     r0,r1,[sp,#0x1c]
00005c  f7fffffe          BL       OLED_DrawLine
;;;1138   		OLED_DrawLine(X1, Y1, X2, Y2);
000060  463b              MOV      r3,r7
000062  4632              MOV      r2,r6
000064  4629              MOV      r1,r5
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       OLED_DrawLine
00006c  e039              B        |L9.226|
                  |L9.110|
;;;1139   	}
;;;1140   	else // 指定三角形填充
;;;1141   	{
;;;1142   		/*找到三个点最小的X、Y坐标*/
;;;1143   		if (X1 < minx)
00006e  4544              CMP      r4,r8
000070  da00              BGE      |L9.116|
;;;1144   		{
;;;1145   			minx = X1;
000072  46a0              MOV      r8,r4
                  |L9.116|
;;;1146   		}
;;;1147   		if (X2 < minx)
000074  4546              CMP      r6,r8
000076  da00              BGE      |L9.122|
;;;1148   		{
;;;1149   			minx = X2;
000078  46b0              MOV      r8,r6
                  |L9.122|
;;;1150   		}
;;;1151   		if (Y1 < miny)
00007a  454d              CMP      r5,r9
00007c  da00              BGE      |L9.128|
;;;1152   		{
;;;1153   			miny = Y1;
00007e  46a9              MOV      r9,r5
                  |L9.128|
;;;1154   		}
;;;1155   		if (Y2 < miny)
000080  454f              CMP      r7,r9
000082  da00              BGE      |L9.134|
;;;1156   		{
;;;1157   			miny = Y2;
000084  46b9              MOV      r9,r7
                  |L9.134|
;;;1158   		}
;;;1159   
;;;1160   		/*找到三个点最大的X、Y坐标*/
;;;1161   		if (X1 > maxx)
000086  9806              LDR      r0,[sp,#0x18]
000088  4284              CMP      r4,r0
00008a  dd00              BLE      |L9.142|
;;;1162   		{
;;;1163   			maxx = X1;
00008c  9406              STR      r4,[sp,#0x18]
                  |L9.142|
;;;1164   		}
;;;1165   		if (X2 > maxx)
00008e  9806              LDR      r0,[sp,#0x18]
000090  4286              CMP      r6,r0
000092  dd00              BLE      |L9.150|
;;;1166   		{
;;;1167   			maxx = X2;
000094  9606              STR      r6,[sp,#0x18]
                  |L9.150|
;;;1168   		}
;;;1169   		if (Y1 > maxy)
000096  455d              CMP      r5,r11
000098  dd00              BLE      |L9.156|
;;;1170   		{
;;;1171   			maxy = Y1;
00009a  46ab              MOV      r11,r5
                  |L9.156|
;;;1172   		}
;;;1173   		if (Y2 > maxy)
00009c  455f              CMP      r7,r11
00009e  dd00              BLE      |L9.162|
;;;1174   		{
;;;1175   			maxy = Y2;
0000a0  46bb              MOV      r11,r7
                  |L9.162|
;;;1176   		}
;;;1177   
;;;1178   		/*最小最大坐标之间的矩形为可能需要填充的区域*/
;;;1179   		/*遍历此区域中所有的点*/
;;;1180   		/*遍历X坐标*/
;;;1181   		for (i = minx; i <= maxx; i++)
0000a2  46c2              MOV      r10,r8
0000a4  e01a              B        |L9.220|
                  |L9.166|
;;;1182   		{
;;;1183   			/*遍历Y坐标*/
;;;1184   			for (j = miny; j <= maxy; j++)
0000a6  f8cd9014          STR      r9,[sp,#0x14]
0000aa  e010              B        |L9.206|
                  |L9.172|
;;;1185   			{
;;;1186   				/*调用OLED_pnpoly，判断指定点是否在指定三角形之中*/
;;;1187   				/*如果在，则画点，如果不在，则不做处理*/
;;;1188   				if (OLED_pnpoly(3, vx, vy, i, j))
0000ac  9805              LDR      r0,[sp,#0x14]
0000ae  4653              MOV      r3,r10
0000b0  aa01              ADD      r2,sp,#4
0000b2  a903              ADD      r1,sp,#0xc
0000b4  9000              STR      r0,[sp,#0]
0000b6  2003              MOVS     r0,#3
0000b8  f7fffffe          BL       OLED_pnpoly
0000bc  b118              CBZ      r0,|L9.198|
;;;1189   				{
;;;1190   					OLED_DrawPoint(i, j);
0000be  4650              MOV      r0,r10
0000c0  9905              LDR      r1,[sp,#0x14]
0000c2  f7fffffe          BL       OLED_DrawPoint
                  |L9.198|
0000c6  9805              LDR      r0,[sp,#0x14]         ;1184
0000c8  1c40              ADDS     r0,r0,#1              ;1184
0000ca  b200              SXTH     r0,r0                 ;1184
0000cc  9005              STR      r0,[sp,#0x14]         ;1184
                  |L9.206|
0000ce  9805              LDR      r0,[sp,#0x14]         ;1184
0000d0  4558              CMP      r0,r11                ;1184
0000d2  ddeb              BLE      |L9.172|
0000d4  f10a0001          ADD      r0,r10,#1             ;1181
0000d8  fa0ffa80          SXTH     r10,r0                ;1181
                  |L9.220|
0000dc  9806              LDR      r0,[sp,#0x18]         ;1181
0000de  4582              CMP      r10,r0                ;1181
0000e0  dde1              BLE      |L9.166|
                  |L9.226|
;;;1191   				}
;;;1192   			}
;;;1193   		}
;;;1194   	}
;;;1195   }
0000e2  b00b              ADD      sp,sp,#0x2c
0000e4  e8bd8ff0          POP      {r4-r11,pc}
;;;1196   
                          ENDP


                          AREA ||i.OLED_GPIO_Init||, CODE, READONLY, ALIGN=2

                  OLED_GPIO_Init PROC
;;;127     */
;;;128    void OLED_GPIO_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;129    {
;;;130    	uint32_t i, j;
;;;131    
;;;132    	/*在初始化前，加入适量延时，待OLED供电稳定*/
;;;133    	for (i = 0; i < 1000; i++)
000002  2400              MOVS     r4,#0
000004  e006              B        |L10.20|
                  |L10.6|
;;;134    	{
;;;135    		for (j = 0; j < 1000; j++)
000006  2500              MOVS     r5,#0
000008  e000              B        |L10.12|
                  |L10.10|
00000a  1c6d              ADDS     r5,r5,#1
                  |L10.12|
00000c  f5b57f7a          CMP      r5,#0x3e8
000010  d3fb              BCC      |L10.10|
000012  1c64              ADDS     r4,r4,#1              ;133
                  |L10.20|
000014  f5b47f7a          CMP      r4,#0x3e8             ;133
000018  d3f5              BCC      |L10.6|
;;;136    			;
;;;137    	}
;;;138    
;;;139    	/*将SCL和SDA引脚初始化为开漏模式*/
;;;140    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  2004              MOVS     r0,#4
00001e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;141    
;;;142    	GPIO_InitTypeDef GPIO_InitStructure;
;;;143    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000022  2014              MOVS     r0,#0x14
000024  f88d0003          STRB     r0,[sp,#3]
;;;144    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000028  2003              MOVS     r0,#3
00002a  f88d0002          STRB     r0,[sp,#2]
;;;145    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
00002e  2010              MOVS     r0,#0x10
000030  f8ad0000          STRH     r0,[sp,#0]
;;;146    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000034  4669              MOV      r1,sp
000036  4808              LDR      r0,|L10.88|
000038  f7fffffe          BL       GPIO_Init
;;;147    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
00003c  2020              MOVS     r0,#0x20
00003e  f8ad0000          STRH     r0,[sp,#0]
;;;148    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  4804              LDR      r0,|L10.88|
000046  f7fffffe          BL       GPIO_Init
;;;149    
;;;150    	/*释放SCL和SDA*/
;;;151    	OLED_W_SCL(1);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       OLED_W_SCL
;;;152    	OLED_W_SDA(1);
000050  2001              MOVS     r0,#1
000052  f7fffffe          BL       OLED_W_SDA
;;;153    }
000056  bd38              POP      {r3-r5,pc}
;;;154    
                          ENDP

                  |L10.88|
                          DCD      0x40010800

                          AREA ||i.OLED_GetPoint||, CODE, READONLY, ALIGN=2

                  OLED_GetPoint PROC
;;;899     */
;;;900    uint8_t OLED_GetPoint(int16_t X, int16_t Y)
000000  b570              PUSH     {r4-r6,lr}
;;;901    {
000002  4602              MOV      r2,r0
;;;902    	if (X >= 0 && X <= 127 && Y >= 0 && Y <= 63) // 超出屏幕的内容不读取
000004  2a00              CMP      r2,#0
000006  db19              BLT      |L11.60|
000008  2a7f              CMP      r2,#0x7f
00000a  dc17              BGT      |L11.60|
00000c  2900              CMP      r1,#0
00000e  db15              BLT      |L11.60|
000010  293f              CMP      r1,#0x3f
000012  dc13              BGT      |L11.60|
;;;903    	{
;;;904    		/*判断指定位置的数据*/
;;;905    		if (OLED_DisplayBuf[Y / 8][X] & 0x01 << (Y % 8))
000014  17cc              ASRS     r4,r1,#31
000016  eb017454          ADD      r4,r1,r4,LSR #29
00001a  10e4              ASRS     r4,r4,#3
00001c  4d08              LDR      r5,|L11.64|
00001e  eb0514c4          ADD      r4,r5,r4,LSL #7
000022  5ca4              LDRB     r4,[r4,r2]
000024  17cd              ASRS     r5,r1,#31
000026  eb017555          ADD      r5,r1,r5,LSR #29
00002a  10ed              ASRS     r5,r5,#3
00002c  eba106c5          SUB      r6,r1,r5,LSL #3
000030  2501              MOVS     r5,#1
000032  40b5              LSLS     r5,r5,r6
000034  402c              ANDS     r4,r4,r5
000036  b10c              CBZ      r4,|L11.60|
;;;906    		{
;;;907    			return 1; // 为1，返回1
000038  2001              MOVS     r0,#1
                  |L11.58|
;;;908    		}
;;;909    	}
;;;910    
;;;911    	return 0; // 否则，返回0
;;;912    }
00003a  bd70              POP      {r4-r6,pc}
                  |L11.60|
00003c  2000              MOVS     r0,#0                 ;911
00003e  e7fc              B        |L11.58|
;;;913    
                          ENDP

                  |L11.64|
                          DCD      OLED_DisplayBuf

                          AREA ||i.OLED_I2C_SendByte||, CODE, READONLY, ALIGN=1

                  OLED_I2C_SendByte PROC
;;;188     */
;;;189    void OLED_I2C_SendByte(uint8_t Byte)
000000  b570              PUSH     {r4-r6,lr}
;;;190    {
000002  4605              MOV      r5,r0
;;;191    	uint8_t i;
;;;192    
;;;193    	/*循环8次，主机依次发送数据的每一位*/
;;;194    	for (i = 0; i < 8; i++)
000004  2400              MOVS     r4,#0
000006  e011              B        |L12.44|
                  |L12.8|
;;;195    	{
;;;196    		/*使用掩码的方式取出Byte的指定一位数据并写入到SDA线*/
;;;197    		/*两个!的作用是，让所有非零的值变为1*/
;;;198    		OLED_W_SDA(!!(Byte & (0x80 >> i)));
000008  2180              MOVS     r1,#0x80
00000a  4121              ASRS     r1,r1,r4
00000c  4029              ANDS     r1,r1,r5
00000e  b109              CBZ      r1,|L12.20|
000010  2101              MOVS     r1,#1
000012  e000              B        |L12.22|
                  |L12.20|
000014  2100              MOVS     r1,#0
                  |L12.22|
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       OLED_W_SDA
;;;199    		OLED_W_SCL(1); // 释放SCL，从机在SCL高电平期间读取SDA
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       OLED_W_SCL
;;;200    		OLED_W_SCL(0); // 拉低SCL，主机开始发送下一位数据
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       OLED_W_SCL
000028  1c60              ADDS     r0,r4,#1              ;194
00002a  b2c4              UXTB     r4,r0                 ;194
                  |L12.44|
00002c  2c08              CMP      r4,#8                 ;194
00002e  dbeb              BLT      |L12.8|
;;;201    	}
;;;202    
;;;203    	OLED_W_SCL(1); // 额外的一个时钟，不处理应答信号
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       OLED_W_SCL
;;;204    	OLED_W_SCL(0);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       OLED_W_SCL
;;;205    }
00003c  bd70              POP      {r4-r6,pc}
;;;206    
                          ENDP


                          AREA ||i.OLED_I2C_Start||, CODE, READONLY, ALIGN=1

                  OLED_I2C_Start PROC
;;;163     */
;;;164    void OLED_I2C_Start(void)
000000  b510              PUSH     {r4,lr}
;;;165    {
;;;166    	OLED_W_SDA(1); // 释放SDA，确保SDA为高电平
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       OLED_W_SDA
;;;167    	OLED_W_SCL(1); // 释放SCL，确保SCL为高电平
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       OLED_W_SCL
;;;168    	OLED_W_SDA(0); // 在SCL高电平期间，拉低SDA，产生起始信号
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       OLED_W_SDA
;;;169    	OLED_W_SCL(0); // 起始后把SCL也拉低，即为了占用总线，也为了方便总线时序的拼接
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       OLED_W_SCL
;;;170    }
00001a  bd10              POP      {r4,pc}
;;;171    
                          ENDP


                          AREA ||i.OLED_I2C_Stop||, CODE, READONLY, ALIGN=1

                  OLED_I2C_Stop PROC
;;;176     */
;;;177    void OLED_I2C_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;178    {
;;;179    	OLED_W_SDA(0); // 拉低SDA，确保SDA为低电平
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       OLED_W_SDA
;;;180    	OLED_W_SCL(1); // 释放SCL，使SCL呈现高电平
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       OLED_W_SCL
;;;181    	OLED_W_SDA(1); // 在SCL高电平期间，释放SDA，产生终止信号
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       OLED_W_SDA
;;;182    }
000014  bd10              POP      {r4,pc}
;;;183    
                          ENDP


                          AREA ||i.OLED_Init||, CODE, READONLY, ALIGN=1

                  OLED_Init PROC
;;;251     */
;;;252    void OLED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;253    {
;;;254    	OLED_GPIO_Init(); // 先调用底层的端口初始化
000002  f7fffffe          BL       OLED_GPIO_Init
;;;255    
;;;256    	/*写入一系列的命令，对OLED进行初始化配置*/
;;;257    	OLED_WriteCommand(0xAE); // 设置显示开启/关闭，0xAE关闭，0xAF开启
000006  20ae              MOVS     r0,#0xae
000008  f7fffffe          BL       OLED_WriteCommand
;;;258    
;;;259    	OLED_WriteCommand(0xD5); // 设置显示时钟分频比/振荡器频率
00000c  20d5              MOVS     r0,#0xd5
00000e  f7fffffe          BL       OLED_WriteCommand
;;;260    	OLED_WriteCommand(0x80); // 0x00~0xFF
000012  2080              MOVS     r0,#0x80
000014  f7fffffe          BL       OLED_WriteCommand
;;;261    
;;;262    	OLED_WriteCommand(0xA8); // 设置多路复用率
000018  20a8              MOVS     r0,#0xa8
00001a  f7fffffe          BL       OLED_WriteCommand
;;;263    	OLED_WriteCommand(0x3F); // 0x0E~0x3F
00001e  203f              MOVS     r0,#0x3f
000020  f7fffffe          BL       OLED_WriteCommand
;;;264    
;;;265    	OLED_WriteCommand(0xD3); // 设置显示偏移
000024  20d3              MOVS     r0,#0xd3
000026  f7fffffe          BL       OLED_WriteCommand
;;;266    	OLED_WriteCommand(0x00); // 0x00~0x7F
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       OLED_WriteCommand
;;;267    
;;;268    	OLED_WriteCommand(0x40); // 设置显示开始行，0x40~0x7F
000030  2040              MOVS     r0,#0x40
000032  f7fffffe          BL       OLED_WriteCommand
;;;269    
;;;270    	OLED_WriteCommand(0xA1); // 设置左右方向，0xA1正常，0xA0左右反置
000036  20a1              MOVS     r0,#0xa1
000038  f7fffffe          BL       OLED_WriteCommand
;;;271    
;;;272    	OLED_WriteCommand(0xC8); // 设置上下方向，0xC8正常，0xC0上下反置
00003c  20c8              MOVS     r0,#0xc8
00003e  f7fffffe          BL       OLED_WriteCommand
;;;273    
;;;274    	OLED_WriteCommand(0xDA); // 设置COM引脚硬件配置
000042  20da              MOVS     r0,#0xda
000044  f7fffffe          BL       OLED_WriteCommand
;;;275    	OLED_WriteCommand(0x12);
000048  2012              MOVS     r0,#0x12
00004a  f7fffffe          BL       OLED_WriteCommand
;;;276    
;;;277    	OLED_WriteCommand(0x81); // 设置对比度
00004e  2081              MOVS     r0,#0x81
000050  f7fffffe          BL       OLED_WriteCommand
;;;278    	OLED_WriteCommand(0xCF); // 0x00~0xFF
000054  20cf              MOVS     r0,#0xcf
000056  f7fffffe          BL       OLED_WriteCommand
;;;279    
;;;280    	OLED_WriteCommand(0xD9); // 设置预充电周期
00005a  20d9              MOVS     r0,#0xd9
00005c  f7fffffe          BL       OLED_WriteCommand
;;;281    	OLED_WriteCommand(0xF1);
000060  20f1              MOVS     r0,#0xf1
000062  f7fffffe          BL       OLED_WriteCommand
;;;282    
;;;283    	OLED_WriteCommand(0xDB); // 设置VCOMH取消选择级别
000066  20db              MOVS     r0,#0xdb
000068  f7fffffe          BL       OLED_WriteCommand
;;;284    	OLED_WriteCommand(0x30);
00006c  2030              MOVS     r0,#0x30
00006e  f7fffffe          BL       OLED_WriteCommand
;;;285    
;;;286    	OLED_WriteCommand(0xA4); // 设置整个显示打开/关闭
000072  20a4              MOVS     r0,#0xa4
000074  f7fffffe          BL       OLED_WriteCommand
;;;287    
;;;288    	OLED_WriteCommand(0xA6); // 设置正常/反色显示，0xA6正常，0xA7反色
000078  20a6              MOVS     r0,#0xa6
00007a  f7fffffe          BL       OLED_WriteCommand
;;;289    
;;;290    	OLED_WriteCommand(0x8D); // 设置充电泵
00007e  208d              MOVS     r0,#0x8d
000080  f7fffffe          BL       OLED_WriteCommand
;;;291    	OLED_WriteCommand(0x14);
000084  2014              MOVS     r0,#0x14
000086  f7fffffe          BL       OLED_WriteCommand
;;;292    
;;;293    	OLED_WriteCommand(0xAF); // 开启显示
00008a  20af              MOVS     r0,#0xaf
00008c  f7fffffe          BL       OLED_WriteCommand
;;;294    
;;;295    	OLED_Clear();  // 清空显存数组
000090  f7fffffe          BL       OLED_Clear
;;;296    	OLED_Update(); // 更新显示，清屏，防止初始化后未显示内容时花屏
000094  f7fffffe          BL       OLED_Update
;;;297    }
000098  bd10              POP      {r4,pc}
;;;298    
                          ENDP


                          AREA ||i.OLED_IsInAngle||, CODE, READONLY, ALIGN=2

                  OLED_IsInAngle PROC
;;;372     */
;;;373    uint8_t OLED_IsInAngle(int16_t X, int16_t Y, int16_t StartAngle, int16_t EndAngle)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;374    {
000004  b087              SUB      sp,sp,#0x1c
000006  468b              MOV      r11,r1
000008  4614              MOV      r4,r2
00000a  4699              MOV      r9,r3
;;;375    	int16_t PointAngle;
;;;376    	PointAngle = atan2(Y, X) / 3.14 * 180; // 计算指定点的弧度，并转换为角度表示
00000c  9807              LDR      r0,[sp,#0x1c]
00000e  f7fffffe          BL       __aeabi_i2d
000012  4605              MOV      r5,r0
000014  460e              MOV      r6,r1
000016  4658              MOV      r0,r11
000018  f7fffffe          BL       __aeabi_i2d
00001c  4607              MOV      r7,r0
00001e  462a              MOV      r2,r5
000020  4633              MOV      r3,r6
000022  f7fffffe          BL       atan2
000026  4a12              LDR      r2,|L16.112|
000028  4b12              LDR      r3,|L16.116|
00002a  e9cd0100          STRD     r0,r1,[sp,#0]
00002e  f7fffffe          BL       __aeabi_ddiv
000032  2200              MOVS     r2,#0
000034  4b10              LDR      r3,|L16.120|
000036  e9cd0102          STRD     r0,r1,[sp,#8]
00003a  f7fffffe          BL       __aeabi_dmul
00003e  e9cd0104          STRD     r0,r1,[sp,#0x10]
000042  f7fffffe          BL       __aeabi_d2iz
000046  fa0ffa80          SXTH     r10,r0
;;;377    	if (StartAngle < EndAngle)			   // 起始角度小于终止角度的情况
00004a  454c              CMP      r4,r9
00004c  da07              BGE      |L16.94|
;;;378    	{
;;;379    		/*如果指定角度在起始终止角度之间，则判定指定点在指定角度*/
;;;380    		if (PointAngle >= StartAngle && PointAngle <= EndAngle)
00004e  45a2              CMP      r10,r4
000050  db0b              BLT      |L16.106|
000052  45ca              CMP      r10,r9
000054  dc09              BGT      |L16.106|
;;;381    		{
;;;382    			return 1;
000056  2001              MOVS     r0,#1
                  |L16.88|
;;;383    		}
;;;384    	}
;;;385    	else // 起始角度大于于终止角度的情况
;;;386    	{
;;;387    		/*如果指定角度大于起始角度或者小于终止角度，则判定指定点在指定角度*/
;;;388    		if (PointAngle >= StartAngle || PointAngle <= EndAngle)
;;;389    		{
;;;390    			return 1;
;;;391    		}
;;;392    	}
;;;393    	return 0; // 不满足以上条件，则判断判定指定点不在指定角度
;;;394    }
000058  b00b              ADD      sp,sp,#0x2c
00005a  e8bd8ff0          POP      {r4-r11,pc}
                  |L16.94|
00005e  45a2              CMP      r10,r4                ;388
000060  da01              BGE      |L16.102|
000062  45ca              CMP      r10,r9                ;388
000064  dc01              BGT      |L16.106|
                  |L16.102|
000066  2001              MOVS     r0,#1                 ;390
000068  e7f6              B        |L16.88|
                  |L16.106|
00006a  2000              MOVS     r0,#0                 ;393
00006c  e7f4              B        |L16.88|
;;;395    
                          ENDP

00006e  0000              DCW      0x0000
                  |L16.112|
                          DCD      0x51eb851f
                  |L16.116|
                          DCD      0x40091eb8
                  |L16.120|
                          DCD      0x40668000

                          AREA ||i.OLED_Pow||, CODE, READONLY, ALIGN=1

                  OLED_Pow PROC
;;;331     */
;;;332    uint32_t OLED_Pow(uint32_t X, uint32_t Y)
000000  b510              PUSH     {r4,lr}
;;;333    {
000002  4602              MOV      r2,r0
;;;334    	uint32_t Result = 1; // 结果默认为1
000004  2001              MOVS     r0,#1
;;;335    	while (Y--)			 // 累乘Y次
000006  e000              B        |L17.10|
                  |L17.8|
;;;336    	{
;;;337    		Result *= X; // 每次把X累乘到结果上
000008  4350              MULS     r0,r2,r0
                  |L17.10|
00000a  1e0b              SUBS     r3,r1,#0              ;335
00000c  f1a10101          SUB      r1,r1,#1              ;335
000010  d1fa              BNE      |L17.8|
;;;338    	}
;;;339    	return Result;
;;;340    }
000012  bd10              POP      {r4,pc}
;;;341    
                          ENDP


                          AREA ||i.OLED_Printf||, CODE, READONLY, ALIGN=1

                  OLED_Printf PROC
;;;867     */
;;;868    void OLED_Printf(int16_t X, int16_t Y, uint8_t FontSize, char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;869    {
000002  b570              PUSH     {r4-r6,lr}
000004  b0c2              SUB      sp,sp,#0x108
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
;;;870    	char String[256];						 // 定义字符数组
;;;871    	va_list arg;							 // 定义可变参数列表数据类型的变量arg
;;;872    	va_start(arg, format);					 // 从format开始，接收参数列表到arg变量
00000c  a84a              ADD      r0,sp,#0x128
00000e  9001              STR      r0,[sp,#4]
;;;873    	vsprintf(String, format, arg);			 // 使用vsprintf打印格式化字符串和参数列表到字符数组中
000010  a802              ADD      r0,sp,#8
000012  9a01              LDR      r2,[sp,#4]
000014  9949              LDR      r1,[sp,#0x124]
000016  f7fffffe          BL       vsprintf
;;;874    	va_end(arg);							 // 结束变量arg
00001a  2000              MOVS     r0,#0
00001c  9001              STR      r0,[sp,#4]
;;;875    	OLED_ShowString(X, Y, String, FontSize); // OLED显示字符数组（字符串）
00001e  4623              MOV      r3,r4
000020  aa02              ADD      r2,sp,#8
000022  4631              MOV      r1,r6
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       OLED_ShowString
;;;876    }
00002a  b042              ADD      sp,sp,#0x108
00002c  bc70              POP      {r4-r6}
00002e  f85dfb14          LDR      pc,[sp],#0x14
;;;877    
                          ENDP


                          AREA ||i.OLED_Reverse||, CODE, READONLY, ALIGN=2

                  OLED_Reverse PROC
;;;512     */
;;;513    void OLED_Reverse(void)
000000  2000              MOVS     r0,#0
;;;514    {
;;;515    	uint8_t i, j;
;;;516    	for (j = 0; j < 8; j++) // 遍历8页
000002  e011              B        |L19.40|
                  |L19.4|
;;;517    	{
;;;518    		for (i = 0; i < 128; i++) // 遍历128列
000004  2100              MOVS     r1,#0
000006  e00b              B        |L19.32|
                  |L19.8|
;;;519    		{
;;;520    			OLED_DisplayBuf[j][i] ^= 0xFF; // 将显存数组数据全部取反
000008  4a09              LDR      r2,|L19.48|
00000a  eb0212c0          ADD      r2,r2,r0,LSL #7
00000e  5c52              LDRB     r2,[r2,r1]
000010  f08202ff          EOR      r2,r2,#0xff
000014  4b06              LDR      r3,|L19.48|
000016  eb0313c0          ADD      r3,r3,r0,LSL #7
00001a  545a              STRB     r2,[r3,r1]
00001c  1c4a              ADDS     r2,r1,#1              ;518
00001e  b2d1              UXTB     r1,r2                 ;518
                  |L19.32|
000020  2980              CMP      r1,#0x80              ;518
000022  dbf1              BLT      |L19.8|
000024  1c42              ADDS     r2,r0,#1              ;516
000026  b2d0              UXTB     r0,r2                 ;516
                  |L19.40|
000028  2808              CMP      r0,#8                 ;516
00002a  dbeb              BLT      |L19.4|
;;;521    		}
;;;522    	}
;;;523    }
00002c  4770              BX       lr
;;;524    
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
                          DCD      OLED_DisplayBuf

                          AREA ||i.OLED_ReverseArea||, CODE, READONLY, ALIGN=2

                  OLED_ReverseArea PROC
;;;533     */
;;;534    void OLED_ReverseArea(int16_t X, int16_t Y, uint8_t Width, uint8_t Height)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;535    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;536    	int16_t i, j;
;;;537    
;;;538    	for (j = Y; j < Y + Height; j++) // 遍历指定页
00000c  4628              MOV      r0,r5
00000e  e038              B        |L20.130|
                  |L20.16|
;;;539    	{
;;;540    		for (i = X; i < X + Width; i++) // 遍历指定列
000010  4622              MOV      r2,r4
000012  e031              B        |L20.120|
                  |L20.20|
;;;541    		{
;;;542    			if (i >= 0 && i <= 127 && j >= 0 && j <= 63) // 超出屏幕的内容不显示
000014  2a00              CMP      r2,#0
000016  db2d              BLT      |L20.116|
000018  2a7f              CMP      r2,#0x7f
00001a  dc2b              BGT      |L20.116|
00001c  2800              CMP      r0,#0
00001e  db29              BLT      |L20.116|
000020  283f              CMP      r0,#0x3f
000022  dc27              BGT      |L20.116|
;;;543    			{
;;;544    				OLED_DisplayBuf[j / 8][i] ^= 0x01 << (j % 8); // 将显存数组指定数据取反
000024  ea4f7ce0          ASR      r12,r0,#31
000028  eb007c5c          ADD      r12,r0,r12,LSR #29
00002c  ea4f0cec          ASR      r12,r12,#3
000030  f8df8058          LDR      r8,|L20.140|
000034  eb081ccc          ADD      r12,r8,r12,LSL #7
000038  f81cc002          LDRB     r12,[r12,r2]
00003c  4603              MOV      r3,r0
00003e  ea4f78e0          ASR      r8,r0,#31
000042  eb007858          ADD      r8,r0,r8,LSR #29
000046  ea4f08e8          ASR      r8,r8,#3
00004a  eba009c8          SUB      r9,r0,r8,LSL #3
00004e  f04f0801          MOV      r8,#1
000052  fa08f809          LSL      r8,r8,r9
000056  ea8c0c08          EOR      r12,r12,r8
00005a  4601              MOV      r1,r0
00005c  ea4f78e0          ASR      r8,r0,#31
000060  eb007858          ADD      r8,r0,r8,LSR #29
000064  ea4f08e8          ASR      r8,r8,#3
000068  f8df9020          LDR      r9,|L20.140|
00006c  eb0918c8          ADD      r8,r9,r8,LSL #7
000070  f808c002          STRB     r12,[r8,r2]
                  |L20.116|
000074  1c51              ADDS     r1,r2,#1              ;540
000076  b20a              SXTH     r2,r1                 ;540
                  |L20.120|
000078  19a1              ADDS     r1,r4,r6              ;540
00007a  4291              CMP      r1,r2                 ;540
00007c  dcca              BGT      |L20.20|
00007e  1c41              ADDS     r1,r0,#1              ;538
000080  b208              SXTH     r0,r1                 ;538
                  |L20.130|
000082  19e9              ADDS     r1,r5,r7              ;538
000084  4281              CMP      r1,r0                 ;538
000086  dcc3              BGT      |L20.16|
;;;545    			}
;;;546    		}
;;;547    	}
;;;548    }
000088  e8bd83f0          POP      {r4-r9,pc}
;;;549    
                          ENDP

                  |L20.140|
                          DCD      OLED_DisplayBuf

                          AREA ||i.OLED_SetCursor||, CODE, READONLY, ALIGN=1

                  OLED_SetCursor PROC
;;;305     */
;;;306    void OLED_SetCursor(uint8_t Page, uint8_t X)
000000  b570              PUSH     {r4-r6,lr}
;;;307    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;308    	/*如果使用此程序驱动1.3寸的OLED显示屏，则需要解除此注释*/
;;;309    	/*因为1.3寸的OLED驱动芯片（SH1106）有132列*/
;;;310    	/*屏幕的起始列接在了第2列，而不是第0列*/
;;;311    	/*所以需要将X加2，才能正常显示*/
;;;312    	//	X += 2;
;;;313    
;;;314    	/*通过指令设置页地址和列地址*/
;;;315    	OLED_WriteCommand(0xB0 | Page);				 // 设置页位置
000006  f04500b0          ORR      r0,r5,#0xb0
00000a  f7fffffe          BL       OLED_WriteCommand
;;;316    	OLED_WriteCommand(0x10 | ((X & 0xF0) >> 4)); // 设置X位置高4位
00000e  2110              MOVS     r1,#0x10
000010  ea411014          ORR      r0,r1,r4,LSR #4
000014  f7fffffe          BL       OLED_WriteCommand
;;;317    	OLED_WriteCommand(0x00 | (X & 0x0F));		 // 设置X位置低4位
000018  f004000f          AND      r0,r4,#0xf
00001c  f7fffffe          BL       OLED_WriteCommand
;;;318    }
000020  bd70              POP      {r4-r6,pc}
;;;319    
                          ENDP


                          AREA ||i.OLED_ShowBinNum||, CODE, READONLY, ALIGN=1

                  OLED_ShowBinNum PROC
;;;703     */
;;;704    void OLED_ShowBinNum(int16_t X, int16_t Y, uint32_t Number, uint8_t Length, uint8_t FontSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;705    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;706    	uint8_t i;
;;;707    	for (i = 0; i < Length; i++) // 遍历数字的每一位
000010  2400              MOVS     r4,#0
000012  e014              B        |L22.62|
                  |L22.20|
;;;708    	{
;;;709    		/*调用OLED_ShowChar函数，依次显示每个数字*/
;;;710    		/*Number / OLED_Pow(2, Length - i - 1) % 2 可以二进制提取数字的每一位*/
;;;711    		/*+ '0' 可将数字转换为字符格式*/
;;;712    		OLED_ShowChar(X + i * FontSize, Y, Number / OLED_Pow(2, Length - i - 1) % 2 + '0', FontSize);
000014  1b28              SUBS     r0,r5,r4
000016  1e41              SUBS     r1,r0,#1
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       OLED_Pow
00001e  fbb7f0f0          UDIV     r0,r7,r0
000022  f0000001          AND      r0,r0,#1
000026  f1000a30          ADD      r10,r0,#0x30
00002a  fb046108          MLA      r1,r4,r8,r6
00002e  b208              SXTH     r0,r1
000030  4643              MOV      r3,r8
000032  4652              MOV      r2,r10
000034  4649              MOV      r1,r9
000036  f7fffffe          BL       OLED_ShowChar
00003a  1c60              ADDS     r0,r4,#1              ;707
00003c  b2c4              UXTB     r4,r0                 ;707
                  |L22.62|
00003e  42ac              CMP      r4,r5                 ;707
000040  dbe8              BLT      |L22.20|
;;;713    	}
;;;714    }
000042  e8bd87f0          POP      {r4-r10,pc}
;;;715    
                          ENDP


                          AREA ||i.OLED_ShowChar||, CODE, READONLY, ALIGN=2

                  OLED_ShowChar PROC
;;;560     */
;;;561    void OLED_ShowChar(int16_t X, int16_t Y, char Char, uint8_t FontSize)
000000  b5f8              PUSH     {r3-r7,lr}
;;;562    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
000006  4614              MOV      r4,r2
000008  461d              MOV      r5,r3
;;;563    	if (FontSize == OLED_8X16) // 字体为宽8像素，高16像素
00000a  2d08              CMP      r5,#8
00000c  d10c              BNE      |L23.40|
;;;564    	{
;;;565    		/*将ASCII字模库OLED_F8x16的指定数据以8*16的图像格式显示*/
;;;566    		OLED_ShowImage(X, Y, 8, 16, OLED_F8x16[Char - ' ']);
00000e  f1a40020          SUB      r0,r4,#0x20
000012  490e              LDR      r1,|L23.76|
000014  eb011000          ADD      r0,r1,r0,LSL #4
000018  2310              MOVS     r3,#0x10
00001a  2208              MOVS     r2,#8
00001c  4639              MOV      r1,r7
00001e  9000              STR      r0,[sp,#0]
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       OLED_ShowImage
000026  e00f              B        |L23.72|
                  |L23.40|
;;;567    	}
;;;568    	else if (FontSize == OLED_6X8) // 字体为宽6像素，高8像素
000028  2d06              CMP      r5,#6
00002a  d10d              BNE      |L23.72|
;;;569    	{
;;;570    		/*将ASCII字模库OLED_F6x8的指定数据以6*8的图像格式显示*/
;;;571    		OLED_ShowImage(X, Y, 6, 8, OLED_F6x8[Char - ' ']);
00002c  f1a40020          SUB      r0,r4,#0x20
000030  eb000040          ADD      r0,r0,r0,LSL #1
000034  4906              LDR      r1,|L23.80|
000036  eb010040          ADD      r0,r1,r0,LSL #1
00003a  2308              MOVS     r3,#8
00003c  2206              MOVS     r2,#6
00003e  4639              MOV      r1,r7
000040  9000              STR      r0,[sp,#0]
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       OLED_ShowImage
                  |L23.72|
;;;572    	}
;;;573    }
000048  bdf8              POP      {r3-r7,pc}
;;;574    
                          ENDP

00004a  0000              DCW      0x0000
                  |L23.76|
                          DCD      OLED_F8x16
                  |L23.80|
                          DCD      OLED_F6x8

                          AREA ||i.OLED_ShowChinese||, CODE, READONLY, ALIGN=2

                  OLED_ShowChinese PROC
;;;769     */
;;;770    void OLED_ShowChinese(int16_t X, int16_t Y, char *Chinese)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;771    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
;;;772    	uint8_t pChinese = 0;
00000a  2700              MOVS     r7,#0
;;;773    	uint8_t pIndex;
;;;774    	uint8_t i;
;;;775    	char SingleChinese[OLED_CHN_CHAR_WIDTH + 1] = {0};
00000c  2000              MOVS     r0,#0
00000e  9001              STR      r0,[sp,#4]
;;;776    
;;;777    	for (i = 0; Chinese[i] != '\0'; i++) // 遍历汉字串
000010  2500              MOVS     r5,#0
000012  e03a              B        |L24.138|
                  |L24.20|
;;;778    	{
;;;779    		SingleChinese[pChinese] = Chinese[i]; // 提取汉字串数据到单个汉字数组
000014  5d70              LDRB     r0,[r6,r5]
000016  a901              ADD      r1,sp,#4
000018  55c8              STRB     r0,[r1,r7]
;;;780    		pChinese++;							  // 计次自增
00001a  1c78              ADDS     r0,r7,#1
00001c  b2c7              UXTB     r7,r0
;;;781    
;;;782    		/*当提取次数到达OLED_CHN_CHAR_WIDTH时，即代表提取到了一个完整的汉字*/
;;;783    		if (pChinese >= OLED_CHN_CHAR_WIDTH)
00001e  2f02              CMP      r7,#2
000020  db31              BLT      |L24.134|
;;;784    		{
;;;785    			pChinese = 0; // 计次归零
000022  2700              MOVS     r7,#0
;;;786    
;;;787    			/*遍历整个汉字字模库，寻找匹配的汉字*/
;;;788    			/*如果找到最后一个汉字（定义为空字符串），则表示汉字未在字模库定义，停止寻找*/
;;;789    			for (pIndex = 0; strcmp(OLED_CF16x16[pIndex].Index, "") != 0; pIndex++)
000024  2400              MOVS     r4,#0
000026  e00c              B        |L24.66|
                  |L24.40|
;;;790    			{
;;;791    				/*找到匹配的汉字*/
;;;792    				if (strcmp(OLED_CF16x16[pIndex].Index, SingleChinese) == 0)
000028  ebc401c4          RSB      r1,r4,r4,LSL #3
00002c  eb010181          ADD      r1,r1,r1,LSL #2
000030  4a18              LDR      r2,|L24.148|
000032  1888              ADDS     r0,r1,r2
000034  a901              ADD      r1,sp,#4
000036  f7fffffe          BL       strcmp
00003a  b900              CBNZ     r0,|L24.62|
;;;793    				{
;;;794    					break; // 跳出循环，此时pIndex的值为指定汉字的索引
00003c  e00c              B        |L24.88|
                  |L24.62|
00003e  1c60              ADDS     r0,r4,#1              ;789
000040  b2c4              UXTB     r4,r0                 ;789
                  |L24.66|
000042  ebc401c4          RSB      r1,r4,r4,LSL #3       ;789
000046  eb010181          ADD      r1,r1,r1,LSL #2       ;789
00004a  4a12              LDR      r2,|L24.148|
00004c  1888              ADDS     r0,r1,r2              ;789
00004e  a112              ADR      r1,|L24.152|
000050  f7fffffe          BL       strcmp
000054  2800              CMP      r0,#0                 ;789
000056  d1e7              BNE      |L24.40|
                  |L24.88|
000058  bf00              NOP      
;;;795    				}
;;;796    			}
;;;797    
;;;798    			/*将汉字字模库OLED_CF16x16的指定数据以16*16的图像格式显示*/
;;;799    			OLED_ShowImage(X + ((i + 1) / OLED_CHN_CHAR_WIDTH - 1) * 16, Y, 16, 16, OLED_CF16x16[pIndex].Data);
00005a  ebc400c4          RSB      r0,r4,r4,LSL #3
00005e  eb000080          ADD      r0,r0,r0,LSL #2
000062  490c              LDR      r1,|L24.148|
000064  4408              ADD      r0,r0,r1
000066  1cc0              ADDS     r0,r0,#3
000068  f1050a01          ADD      r10,r5,#1
00006c  eb0a71da          ADD      r1,r10,r10,LSR #31
000070  1049              ASRS     r1,r1,#1
000072  1e49              SUBS     r1,r1,#1
000074  eb081101          ADD      r1,r8,r1,LSL #4
000078  9000              STR      r0,[sp,#0]
00007a  b208              SXTH     r0,r1
00007c  2310              MOVS     r3,#0x10
00007e  461a              MOV      r2,r3
000080  4649              MOV      r1,r9
000082  f7fffffe          BL       OLED_ShowImage
                  |L24.134|
000086  1c68              ADDS     r0,r5,#1              ;777
000088  b2c5              UXTB     r5,r0                 ;777
                  |L24.138|
00008a  5d70              LDRB     r0,[r6,r5]            ;777
00008c  2800              CMP      r0,#0                 ;777
00008e  d1c1              BNE      |L24.20|
;;;800    		}
;;;801    	}
;;;802    }
000090  e8bd87fc          POP      {r2-r10,pc}
;;;803    
                          ENDP

                  |L24.148|
                          DCD      OLED_CF16x16
                  |L24.152|
000098  00                DCB      0
000099  00                DCB      0
00009a  00                DCB      0
00009b  00                DCB      0

                          AREA ||i.OLED_ShowFloatNum||, CODE, READONLY, ALIGN=1

                  OLED_ShowFloatNum PROC
;;;728     */
;;;729    void OLED_ShowFloatNum(int16_t X, int16_t Y, double Number, uint8_t IntLength, uint8_t FraLength, uint8_t FontSize)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;730    {
000004  b086              SUB      sp,sp,#0x18
000006  4607              MOV      r7,r0
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8050          LDR      r8,[sp,#0x50]
000010  9e16              LDR      r6,[sp,#0x58]
;;;731    	uint32_t PowNum, IntNum, FraNum;
;;;732    
;;;733    	if (Number >= 0) // 数字大于等于0
000012  2200              MOVS     r2,#0
000014  4613              MOV      r3,r2
000016  4620              MOV      r0,r4
000018  4629              MOV      r1,r5
00001a  f7fffffe          BL       __aeabi_cdrcmple
00001e  d806              BHI      |L25.46|
;;;734    	{
;;;735    		OLED_ShowChar(X, Y, '+', FontSize); // 显示+号
000020  4633              MOV      r3,r6
000022  222b              MOVS     r2,#0x2b
000024  4638              MOV      r0,r7
000026  9907              LDR      r1,[sp,#0x1c]
000028  f7fffffe          BL       OLED_ShowChar
00002c  e007              B        |L25.62|
                  |L25.46|
;;;736    	}
;;;737    	else // 数字小于0
;;;738    	{
;;;739    		OLED_ShowChar(X, Y, '-', FontSize); // 显示-号
00002e  4633              MOV      r3,r6
000030  222d              MOVS     r2,#0x2d
000032  4638              MOV      r0,r7
000034  9907              LDR      r1,[sp,#0x1c]
000036  f7fffffe          BL       OLED_ShowChar
;;;740    		Number = -Number;					// Number取负
00003a  f0854500          EOR      r5,r5,#0x80000000
                  |L25.62|
;;;741    	}
;;;742    
;;;743    	/*提取整数部分和小数部分*/
;;;744    	IntNum = Number;				  // 直接赋值给整型变量，提取整数
00003e  4620              MOV      r0,r4
000040  4629              MOV      r1,r5
000042  f7fffffe          BL       __aeabi_d2uiz
000046  4682              MOV      r10,r0
;;;745    	Number -= IntNum;				  // 将Number的整数减掉，防止之后将小数乘到整数时因数过大造成错误
000048  4650              MOV      r0,r10
00004a  f7fffffe          BL       __aeabi_ui2d
00004e  4622              MOV      r2,r4
000050  462b              MOV      r3,r5
000052  e9cd0104          STRD     r0,r1,[sp,#0x10]
000056  f7fffffe          BL       __aeabi_drsub
00005a  4604              MOV      r4,r0
00005c  460d              MOV      r5,r1
;;;746    	PowNum = OLED_Pow(10, FraLength); // 根据指定小数的位数，确定乘数
00005e  200a              MOVS     r0,#0xa
000060  9915              LDR      r1,[sp,#0x54]
000062  f7fffffe          BL       OLED_Pow
000066  4681              MOV      r9,r0
;;;747    	FraNum = round(Number * PowNum);  // 将小数乘到整数，同时四舍五入，避免显示误差
000068  4648              MOV      r0,r9
00006a  f7fffffe          BL       __aeabi_ui2d
00006e  4622              MOV      r2,r4
000070  462b              MOV      r3,r5
000072  e9cd0100          STRD     r0,r1,[sp,#0]
000076  f7fffffe          BL       __aeabi_dmul
00007a  e9cd0102          STRD     r0,r1,[sp,#8]
00007e  f7fffffe          BL       round
000082  e9cd0104          STRD     r0,r1,[sp,#0x10]
000086  f7fffffe          BL       __aeabi_d2uiz
00008a  4683              MOV      r11,r0
;;;748    	IntNum += FraNum / PowNum;		  // 若四舍五入造成了进位，则需要再加给整数
00008c  fbbbf0f9          UDIV     r0,r11,r9
000090  4482              ADD      r10,r10,r0
;;;749    
;;;750    	/*显示整数部分*/
;;;751    	OLED_ShowNum(X + FontSize, Y, IntNum, IntLength, FontSize);
000092  19b9              ADDS     r1,r7,r6
000094  b208              SXTH     r0,r1
000096  4643              MOV      r3,r8
000098  4652              MOV      r2,r10
00009a  9600              STR      r6,[sp,#0]
00009c  9907              LDR      r1,[sp,#0x1c]
00009e  f7fffffe          BL       OLED_ShowNum
;;;752    
;;;753    	/*显示小数点*/
;;;754    	OLED_ShowChar(X + (IntLength + 1) * FontSize, Y, '.', FontSize);
0000a2  f1080101          ADD      r1,r8,#1
0000a6  fb017106          MLA      r1,r1,r6,r7
0000aa  b208              SXTH     r0,r1
0000ac  4633              MOV      r3,r6
0000ae  222e              MOVS     r2,#0x2e
0000b0  9907              LDR      r1,[sp,#0x1c]
0000b2  f7fffffe          BL       OLED_ShowChar
;;;755    
;;;756    	/*显示小数部分*/
;;;757    	OLED_ShowNum(X + (IntLength + 2) * FontSize, Y, FraNum, FraLength, FontSize);
0000b6  f1080102          ADD      r1,r8,#2
0000ba  fb017106          MLA      r1,r1,r6,r7
0000be  b208              SXTH     r0,r1
0000c0  9600              STR      r6,[sp,#0]
0000c2  465a              MOV      r2,r11
0000c4  9b15              LDR      r3,[sp,#0x54]
0000c6  9907              LDR      r1,[sp,#0x1c]
0000c8  f7fffffe          BL       OLED_ShowNum
;;;758    }
0000cc  b00a              ADD      sp,sp,#0x28
0000ce  e8bd9ff0          POP      {r4-r12,pc}
;;;759    
                          ENDP


                          AREA ||i.OLED_ShowHexNum||, CODE, READONLY, ALIGN=1

                  OLED_ShowHexNum PROC
;;;668     */
;;;669    void OLED_ShowHexNum(int16_t X, int16_t Y, uint32_t Number, uint8_t Length, uint8_t FontSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;670    {
000004  4606              MOV      r6,r0
000006  468a              MOV      r10,r1
000008  4691              MOV      r9,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;671    	uint8_t i, SingleNumber;
;;;672    	for (i = 0; i < Length; i++) // 遍历数字的每一位
000010  2400              MOVS     r4,#0
000012  e021              B        |L26.88|
                  |L26.20|
;;;673    	{
;;;674    		/*以十六进制提取数字的每一位*/
;;;675    		SingleNumber = Number / OLED_Pow(16, Length - i - 1) % 16;
000014  1b38              SUBS     r0,r7,r4
000016  1e41              SUBS     r1,r0,#1
000018  2010              MOVS     r0,#0x10
00001a  f7fffffe          BL       OLED_Pow
00001e  fbb9f0f0          UDIV     r0,r9,r0
000022  f000050f          AND      r5,r0,#0xf
;;;676    
;;;677    		if (SingleNumber < 10) // 单个数字小于10
000026  2d0a              CMP      r5,#0xa
000028  da0a              BGE      |L26.64|
;;;678    		{
;;;679    			/*调用OLED_ShowChar函数，显示此数字*/
;;;680    			/*+ '0' 可将数字转换为字符格式*/
;;;681    			OLED_ShowChar(X + i * FontSize, Y, SingleNumber + '0', FontSize);
00002a  f1050130          ADD      r1,r5,#0x30
00002e  b2ca              UXTB     r2,r1
000030  fb046108          MLA      r1,r4,r8,r6
000034  b208              SXTH     r0,r1
000036  4643              MOV      r3,r8
000038  4651              MOV      r1,r10
00003a  f7fffffe          BL       OLED_ShowChar
00003e  e009              B        |L26.84|
                  |L26.64|
;;;682    		}
;;;683    		else // 单个数字大于10
;;;684    		{
;;;685    			/*调用OLED_ShowChar函数，显示此数字*/
;;;686    			/*+ 'A' 可将数字转换为从A开始的十六进制字符*/
;;;687    			OLED_ShowChar(X + i * FontSize, Y, SingleNumber - 10 + 'A', FontSize);
000040  f1050137          ADD      r1,r5,#0x37
000044  b2ca              UXTB     r2,r1
000046  fb046108          MLA      r1,r4,r8,r6
00004a  b208              SXTH     r0,r1
00004c  4643              MOV      r3,r8
00004e  4651              MOV      r1,r10
000050  f7fffffe          BL       OLED_ShowChar
                  |L26.84|
000054  1c60              ADDS     r0,r4,#1              ;672
000056  b2c4              UXTB     r4,r0                 ;672
                  |L26.88|
000058  42bc              CMP      r4,r7                 ;672
00005a  dbdb              BLT      |L26.20|
;;;688    		}
;;;689    	}
;;;690    }
00005c  e8bd87f0          POP      {r4-r10,pc}
;;;691    
                          ENDP


                          AREA ||i.OLED_ShowImage||, CODE, READONLY, ALIGN=2

                  OLED_ShowImage PROC
;;;813     */
;;;814    void OLED_ShowImage(int16_t X, int16_t Y, uint8_t Width, uint8_t Height, const uint8_t *Image)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;815    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4691              MOV      r9,r2
00000a  f8ddb034          LDR      r11,[sp,#0x34]
;;;816    	uint8_t i = 0, j = 0;
00000e  2500              MOVS     r5,#0
000010  2400              MOVS     r4,#0
;;;817    	int16_t Page, Shift;
;;;818    
;;;819    	/*将图像所在区域清空*/
;;;820    	OLED_ClearArea(X, Y, Width, Height);
000012  464a              MOV      r2,r9
000014  4631              MOV      r1,r6
000016  4640              MOV      r0,r8
000018  9b03              LDR      r3,[sp,#0xc]
00001a  f7fffffe          BL       OLED_ClearArea
;;;821    
;;;822    	/*遍历指定图像涉及的相关页*/
;;;823    	/*(Height - 1) / 8 + 1的目的是Height / 8并向上取整*/
;;;824    	for (j = 0; j < (Height - 1) / 8 + 1; j++)
00001e  bf00              NOP      
000020  e05e              B        |L27.224|
                  |L27.34|
;;;825    	{
;;;826    		/*遍历指定图像涉及的相关列*/
;;;827    		for (i = 0; i < Width; i++)
000022  2500              MOVS     r5,#0
000024  e058              B        |L27.216|
                  |L27.38|
;;;828    		{
;;;829    			if (X + i >= 0 && X + i <= 127) // 超出屏幕的内容不显示
000026  eb080005          ADD      r0,r8,r5
00002a  2800              CMP      r0,#0
00002c  db52              BLT      |L27.212|
00002e  eb080005          ADD      r0,r8,r5
000032  287f              CMP      r0,#0x7f
000034  dc4e              BGT      |L27.212|
;;;830    			{
;;;831    				/*负数坐标在计算页地址和移位时需要加一个偏移*/
;;;832    				Page = Y / 8;
000036  4630              MOV      r0,r6
000038  17f1              ASRS     r1,r6,#31
00003a  eb067151          ADD      r1,r6,r1,LSR #29
00003e  10c9              ASRS     r1,r1,#3
000040  b20f              SXTH     r7,r1
;;;833    				Shift = Y % 8;
000042  17f1              ASRS     r1,r6,#31
000044  eb067151          ADD      r1,r6,r1,LSR #29
000048  10c9              ASRS     r1,r1,#3
00004a  eba60ac1          SUB      r10,r6,r1,LSL #3
;;;834    				if (Y < 0)
00004e  2e00              CMP      r6,#0
000050  da05              BGE      |L27.94|
;;;835    				{
;;;836    					Page -= 1;
000052  1e78              SUBS     r0,r7,#1
000054  b207              SXTH     r7,r0
;;;837    					Shift += 8;
000056  f10a0008          ADD      r0,r10,#8
00005a  fa0ffa80          SXTH     r10,r0
                  |L27.94|
;;;838    				}
;;;839    
;;;840    				if (Page + j >= 0 && Page + j <= 7) // 超出屏幕的内容不显示
00005e  1938              ADDS     r0,r7,r4
000060  2800              CMP      r0,#0
000062  db17              BLT      |L27.148|
000064  1938              ADDS     r0,r7,r4
000066  2807              CMP      r0,#7
000068  dc14              BGT      |L27.148|
;;;841    				{
;;;842    					/*显示图像在当前页的内容*/
;;;843    					OLED_DisplayBuf[Page + j][X + i] |= Image[j * Width + i] << (Shift);
00006a  1938              ADDS     r0,r7,r4
00006c  4922              LDR      r1,|L27.248|
00006e  eb0110c0          ADD      r0,r1,r0,LSL #7
000072  eb080105          ADD      r1,r8,r5
000076  5c40              LDRB     r0,[r0,r1]
000078  fb045109          MLA      r1,r4,r9,r5
00007c  f81b1001          LDRB     r1,[r11,r1]
000080  fa01f10a          LSL      r1,r1,r10
000084  4308              ORRS     r0,r0,r1
000086  1939              ADDS     r1,r7,r4
000088  4a1b              LDR      r2,|L27.248|
00008a  eb0211c1          ADD      r1,r2,r1,LSL #7
00008e  eb080205          ADD      r2,r8,r5
000092  5488              STRB     r0,[r1,r2]
                  |L27.148|
;;;844    				}
;;;845    
;;;846    				if (Page + j + 1 >= 0 && Page + j + 1 <= 7) // 超出屏幕的内容不显示
000094  1938              ADDS     r0,r7,r4
000096  1c40              ADDS     r0,r0,#1
000098  2800              CMP      r0,#0
00009a  db1b              BLT      |L27.212|
00009c  1938              ADDS     r0,r7,r4
00009e  1c40              ADDS     r0,r0,#1
0000a0  2807              CMP      r0,#7
0000a2  dc17              BGT      |L27.212|
;;;847    				{
;;;848    					/*显示图像在下一页的内容*/
;;;849    					OLED_DisplayBuf[Page + j + 1][X + i] |= Image[j * Width + i] >> (8 - Shift);
0000a4  1938              ADDS     r0,r7,r4
0000a6  1c40              ADDS     r0,r0,#1
0000a8  4913              LDR      r1,|L27.248|
0000aa  eb0110c0          ADD      r0,r1,r0,LSL #7
0000ae  eb080105          ADD      r1,r8,r5
0000b2  5c40              LDRB     r0,[r0,r1]
0000b4  fb045109          MLA      r1,r4,r9,r5
0000b8  f81b1001          LDRB     r1,[r11,r1]
0000bc  f1ca0208          RSB      r2,r10,#8
0000c0  4111              ASRS     r1,r1,r2
0000c2  4308              ORRS     r0,r0,r1
0000c4  1939              ADDS     r1,r7,r4
0000c6  1c49              ADDS     r1,r1,#1
0000c8  4a0b              LDR      r2,|L27.248|
0000ca  eb0211c1          ADD      r1,r2,r1,LSL #7
0000ce  eb080205          ADD      r2,r8,r5
0000d2  5488              STRB     r0,[r1,r2]
                  |L27.212|
0000d4  1c68              ADDS     r0,r5,#1              ;827
0000d6  b2c5              UXTB     r5,r0                 ;827
                  |L27.216|
0000d8  454d              CMP      r5,r9                 ;827
0000da  dba4              BLT      |L27.38|
0000dc  1c60              ADDS     r0,r4,#1              ;824
0000de  b2c4              UXTB     r4,r0                 ;824
                  |L27.224|
0000e0  9903              LDR      r1,[sp,#0xc]          ;824
0000e2  1e48              SUBS     r0,r1,#1              ;824
0000e4  17c1              ASRS     r1,r0,#31             ;824
0000e6  eb007151          ADD      r1,r0,r1,LSR #29      ;824
0000ea  2201              MOVS     r2,#1                 ;824
0000ec  eb0201e1          ADD      r1,r2,r1,ASR #3       ;824
0000f0  42a1              CMP      r1,r4                 ;824
0000f2  dc96              BGT      |L27.34|
;;;850    				}
;;;851    			}
;;;852    		}
;;;853    	}
;;;854    }
0000f4  e8bd8fff          POP      {r0-r11,pc}
;;;855    
                          ENDP

                  |L27.248|
                          DCD      OLED_DisplayBuf

                          AREA ||i.OLED_ShowNum||, CODE, READONLY, ALIGN=1

                  OLED_ShowNum PROC
;;;607     */
;;;608    void OLED_ShowNum(int16_t X, int16_t Y, uint32_t Number, uint8_t Length, uint8_t FontSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;609    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;610    	uint8_t i;
;;;611    	for (i = 0; i < Length; i++) // 遍历数字的每一位
000010  2400              MOVS     r4,#0
000012  e017              B        |L28.68|
                  |L28.20|
;;;612    	{
;;;613    		/*调用OLED_ShowChar函数，依次显示每个数字*/
;;;614    		/*Number / OLED_Pow(10, Length - i - 1) % 10 可以十进制提取数字的每一位*/
;;;615    		/*+ '0' 可将数字转换为字符格式*/
;;;616    		OLED_ShowChar(X + i * FontSize, Y, Number / OLED_Pow(10, Length - i - 1) % 10 + '0', FontSize);
000014  1b28              SUBS     r0,r5,r4
000016  1e41              SUBS     r1,r0,#1
000018  200a              MOVS     r0,#0xa
00001a  f7fffffe          BL       OLED_Pow
00001e  fbb7f0f0          UDIV     r0,r7,r0
000022  210a              MOVS     r1,#0xa
000024  fbb0f2f1          UDIV     r2,r0,r1
000028  fb010012          MLS      r0,r1,r2,r0
00002c  f1000a30          ADD      r10,r0,#0x30
000030  fb046108          MLA      r1,r4,r8,r6
000034  b208              SXTH     r0,r1
000036  4643              MOV      r3,r8
000038  4652              MOV      r2,r10
00003a  4649              MOV      r1,r9
00003c  f7fffffe          BL       OLED_ShowChar
000040  1c60              ADDS     r0,r4,#1              ;611
000042  b2c4              UXTB     r4,r0                 ;611
                  |L28.68|
000044  42ac              CMP      r4,r5                 ;611
000046  dbe5              BLT      |L28.20|
;;;617    	}
;;;618    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;619    
                          ENDP


                          AREA ||i.OLED_ShowSignedNum||, CODE, READONLY, ALIGN=1

                  OLED_ShowSignedNum PROC
;;;631     */
;;;632    void OLED_ShowSignedNum(int16_t X, int16_t Y, int32_t Number, uint8_t Length, uint8_t FontSize)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;633    {
000004  4680              MOV      r8,r0
000006  468a              MOV      r10,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  f8dd9024          LDR      r9,[sp,#0x24]
;;;634    	uint8_t i;
;;;635    	uint32_t Number1;
;;;636    
;;;637    	if (Number >= 0) // 数字大于等于0
000010  2d00              CMP      r5,#0
000012  db07              BLT      |L29.36|
;;;638    	{
;;;639    		OLED_ShowChar(X, Y, '+', FontSize); // 显示+号
000014  464b              MOV      r3,r9
000016  222b              MOVS     r2,#0x2b
000018  4651              MOV      r1,r10
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       OLED_ShowChar
;;;640    		Number1 = Number;					// Number1直接等于Number
000020  462f              MOV      r7,r5
000022  e006              B        |L29.50|
                  |L29.36|
;;;641    	}
;;;642    	else // 数字小于0
;;;643    	{
;;;644    		OLED_ShowChar(X, Y, '-', FontSize); // 显示-号
000024  464b              MOV      r3,r9
000026  222d              MOVS     r2,#0x2d
000028  4651              MOV      r1,r10
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       OLED_ShowChar
;;;645    		Number1 = -Number;					// Number1等于Number取负
000030  426f              RSBS     r7,r5,#0
                  |L29.50|
;;;646    	}
;;;647    
;;;648    	for (i = 0; i < Length; i++) // 遍历数字的每一位
000032  2400              MOVS     r4,#0
000034  e018              B        |L29.104|
                  |L29.54|
;;;649    	{
;;;650    		/*调用OLED_ShowChar函数，依次显示每个数字*/
;;;651    		/*Number1 / OLED_Pow(10, Length - i - 1) % 10 可以十进制提取数字的每一位*/
;;;652    		/*+ '0' 可将数字转换为字符格式*/
;;;653    		OLED_ShowChar(X + (i + 1) * FontSize, Y, Number1 / OLED_Pow(10, Length - i - 1) % 10 + '0', FontSize);
000036  1b30              SUBS     r0,r6,r4
000038  1e41              SUBS     r1,r0,#1
00003a  200a              MOVS     r0,#0xa
00003c  f7fffffe          BL       OLED_Pow
000040  fbb7f0f0          UDIV     r0,r7,r0
000044  210a              MOVS     r1,#0xa
000046  fbb0f2f1          UDIV     r2,r0,r1
00004a  fb010012          MLS      r0,r1,r2,r0
00004e  f1000b30          ADD      r11,r0,#0x30
000052  1c61              ADDS     r1,r4,#1
000054  fb018109          MLA      r1,r1,r9,r8
000058  b208              SXTH     r0,r1
00005a  464b              MOV      r3,r9
00005c  465a              MOV      r2,r11
00005e  4651              MOV      r1,r10
000060  f7fffffe          BL       OLED_ShowChar
000064  1c60              ADDS     r0,r4,#1              ;648
000066  b2c4              UXTB     r4,r0                 ;648
                  |L29.104|
000068  42b4              CMP      r4,r6                 ;648
00006a  dbe4              BLT      |L29.54|
;;;654    	}
;;;655    }
00006c  e8bd8ff0          POP      {r4-r11,pc}
;;;656    
                          ENDP


                          AREA ||i.OLED_ShowString||, CODE, READONLY, ALIGN=1

                  OLED_ShowString PROC
;;;585     */
;;;586    void OLED_ShowString(int16_t X, int16_t Y, char *String, uint8_t FontSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;587    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;588    	uint8_t i;
;;;589    	for (i = 0; String[i] != '\0'; i++) // 遍历字符串的每个字符
00000c  2400              MOVS     r4,#0
00000e  e009              B        |L30.36|
                  |L30.16|
;;;590    	{
;;;591    		/*调用OLED_ShowChar函数，依次显示每个字符*/
;;;592    		OLED_ShowChar(X + i * FontSize, Y, String[i], FontSize);
000010  5d2a              LDRB     r2,[r5,r4]
000012  fb046107          MLA      r1,r4,r7,r6
000016  b208              SXTH     r0,r1
000018  463b              MOV      r3,r7
00001a  4641              MOV      r1,r8
00001c  f7fffffe          BL       OLED_ShowChar
000020  1c60              ADDS     r0,r4,#1              ;589
000022  b2c4              UXTB     r4,r0                 ;589
                  |L30.36|
000024  5d28              LDRB     r0,[r5,r4]            ;589
000026  2800              CMP      r0,#0                 ;589
000028  d1f2              BNE      |L30.16|
;;;593    	}
;;;594    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;595    
                          ENDP


                          AREA ||i.OLED_Update||, CODE, READONLY, ALIGN=2

                  OLED_Update PROC
;;;408     */
;;;409    void OLED_Update(void)
000000  b510              PUSH     {r4,lr}
;;;410    {
;;;411    	uint8_t j;
;;;412    	/*遍历每一页*/
;;;413    	for (j = 0; j < 8; j++)
000002  2400              MOVS     r4,#0
000004  e00b              B        |L31.30|
                  |L31.6|
;;;414    	{
;;;415    		/*设置光标位置为每一页的第一列*/
;;;416    		OLED_SetCursor(j, 0);
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       OLED_SetCursor
;;;417    		/*连续写入128个数据，将显存数组的数据写入到OLED硬件*/
;;;418    		OLED_WriteData(OLED_DisplayBuf[j], 128);
00000e  4905              LDR      r1,|L31.36|
000010  eb0110c4          ADD      r0,r1,r4,LSL #7
000014  2180              MOVS     r1,#0x80
000016  f7fffffe          BL       OLED_WriteData
00001a  1c60              ADDS     r0,r4,#1              ;413
00001c  b2c4              UXTB     r4,r0                 ;413
                  |L31.30|
00001e  2c08              CMP      r4,#8                 ;413
000020  dbf1              BLT      |L31.6|
;;;419    	}
;;;420    }
000022  bd10              POP      {r4,pc}
;;;421    
                          ENDP

                  |L31.36|
                          DCD      OLED_DisplayBuf

                          AREA ||i.OLED_UpdateArea||, CODE, READONLY, ALIGN=2

                  OLED_UpdateArea PROC
;;;435     */
;;;436    void OLED_UpdateArea(int16_t X, int16_t Y, uint8_t Width, uint8_t Height)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;437    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;438    	int16_t j;
;;;439    	int16_t Page, Page1;
;;;440    
;;;441    	/*负数坐标在计算页地址时需要加一个偏移*/
;;;442    	/*(Y + Height - 1) / 8 + 1的目的是(Y + Height) / 8并向上取整*/
;;;443    	Page = Y / 8;
00000c  4628              MOV      r0,r5
00000e  17e9              ASRS     r1,r5,#31
000010  eb057151          ADD      r1,r5,r1,LSR #29
000014  10c9              ASRS     r1,r1,#3
000016  fa0ff981          SXTH     r9,r1
;;;444    	Page1 = (Y + Height - 1) / 8 + 1;
00001a  eb050108          ADD      r1,r5,r8
00001e  1e48              SUBS     r0,r1,#1
000020  17c1              ASRS     r1,r0,#31
000022  eb007151          ADD      r1,r0,r1,LSR #29
000026  10c9              ASRS     r1,r1,#3
000028  1c49              ADDS     r1,r1,#1
00002a  fa0ffa81          SXTH     r10,r1
;;;445    	if (Y < 0)
00002e  2d00              CMP      r5,#0
000030  da07              BGE      |L32.66|
;;;446    	{
;;;447    		Page -= 1;
000032  f1a90001          SUB      r0,r9,#1
000036  fa0ff980          SXTH     r9,r0
;;;448    		Page1 -= 1;
00003a  f1aa0001          SUB      r0,r10,#1
00003e  fa0ffa80          SXTH     r10,r0
                  |L32.66|
;;;449    	}
;;;450    
;;;451    	/*遍历指定区域涉及的相关页*/
;;;452    	for (j = Page; j < Page1; j++)
000042  464c              MOV      r4,r9
000044  e014              B        |L32.112|
                  |L32.70|
;;;453    	{
;;;454    		if (X >= 0 && X <= 127 && j >= 0 && j <= 7) // 超出屏幕的内容不显示
000046  2e00              CMP      r6,#0
000048  db10              BLT      |L32.108|
00004a  2e7f              CMP      r6,#0x7f
00004c  dc0e              BGT      |L32.108|
00004e  2c00              CMP      r4,#0
000050  db0c              BLT      |L32.108|
000052  2c07              CMP      r4,#7
000054  dc0a              BGT      |L32.108|
;;;455    		{
;;;456    			/*设置光标位置为相关页的指定列*/
;;;457    			OLED_SetCursor(j, X);
000056  b2f1              UXTB     r1,r6
000058  b2e0              UXTB     r0,r4
00005a  f7fffffe          BL       OLED_SetCursor
;;;458    			/*连续写入Width个数据，将显存数组的数据写入到OLED硬件*/
;;;459    			OLED_WriteData(&OLED_DisplayBuf[j][X], Width);
00005e  4906              LDR      r1,|L32.120|
000060  eb0111c4          ADD      r1,r1,r4,LSL #7
000064  1988              ADDS     r0,r1,r6
000066  4639              MOV      r1,r7
000068  f7fffffe          BL       OLED_WriteData
                  |L32.108|
00006c  1c60              ADDS     r0,r4,#1              ;452
00006e  b204              SXTH     r4,r0                 ;452
                  |L32.112|
000070  4554              CMP      r4,r10                ;452
000072  dbe8              BLT      |L32.70|
;;;460    		}
;;;461    	}
;;;462    }
000074  e8bd87f0          POP      {r4-r10,pc}
;;;463    
                          ENDP

                  |L32.120|
                          DCD      OLED_DisplayBuf

                          AREA ||i.OLED_W_SCL||, CODE, READONLY, ALIGN=2

                  OLED_W_SCL PROC
;;;94      */
;;;95     void OLED_W_SCL(uint8_t BitValue)
000000  b510              PUSH     {r4,lr}
;;;96     {
000002  4604              MOV      r4,r0
;;;97     	/*根据BitValue的值，将SCL置高电平或者低电平*/
;;;98     	GPIO_WriteBit(GPIOA, GPIO_Pin_4, (BitAction)BitValue);
000004  4622              MOV      r2,r4
000006  2110              MOVS     r1,#0x10
000008  4801              LDR      r0,|L33.16|
00000a  f7fffffe          BL       GPIO_WriteBit
;;;99     
;;;100    	/*如果单片机速度过快，可在此添加适量延时，以避免超出I2C通信的最大速度*/
;;;101    	//...
;;;102    }
00000e  bd10              POP      {r4,pc}
;;;103    
                          ENDP

                  |L33.16|
                          DCD      0x40010800

                          AREA ||i.OLED_W_SDA||, CODE, READONLY, ALIGN=2

                  OLED_W_SDA PROC
;;;111     */
;;;112    void OLED_W_SDA(uint8_t BitValue)
000000  b510              PUSH     {r4,lr}
;;;113    {
000002  4604              MOV      r4,r0
;;;114    	/*根据BitValue的值，将SDA置高电平或者低电平*/
;;;115    	GPIO_WriteBit(GPIOA, GPIO_Pin_5, (BitAction)BitValue);
000004  4622              MOV      r2,r4
000006  2120              MOVS     r1,#0x20
000008  4801              LDR      r0,|L34.16|
00000a  f7fffffe          BL       GPIO_WriteBit
;;;116    
;;;117    	/*如果单片机速度过快，可在此添加适量延时，以避免超出I2C通信的最大速度*/
;;;118    	//...
;;;119    }
00000e  bd10              POP      {r4,pc}
;;;120    
                          ENDP

                  |L34.16|
                          DCD      0x40010800

                          AREA ||i.OLED_WriteCommand||, CODE, READONLY, ALIGN=1

                  OLED_WriteCommand PROC
;;;211     */
;;;212    void OLED_WriteCommand(uint8_t Command)
000000  b510              PUSH     {r4,lr}
;;;213    {
000002  4604              MOV      r4,r0
;;;214    	OLED_I2C_Start();			// I2C起始
000004  f7fffffe          BL       OLED_I2C_Start
;;;215    	OLED_I2C_SendByte(0x78);	// 发送OLED的I2C从机地址
000008  2078              MOVS     r0,#0x78
00000a  f7fffffe          BL       OLED_I2C_SendByte
;;;216    	OLED_I2C_SendByte(0x00);	// 控制字节，给0x00，表示即将写命令
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       OLED_I2C_SendByte
;;;217    	OLED_I2C_SendByte(Command); // 写入指定的命令
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       OLED_I2C_SendByte
;;;218    	OLED_I2C_Stop();			// I2C终止
00001a  f7fffffe          BL       OLED_I2C_Stop
;;;219    }
00001e  bd10              POP      {r4,pc}
;;;220    
                          ENDP


                          AREA ||i.OLED_WriteData||, CODE, READONLY, ALIGN=1

                  OLED_WriteData PROC
;;;226     */
;;;227    void OLED_WriteData(uint8_t *Data, uint8_t Count)
000000  b570              PUSH     {r4-r6,lr}
;;;228    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;229    	uint8_t i;
;;;230    
;;;231    	OLED_I2C_Start();		 // I2C起始
000006  f7fffffe          BL       OLED_I2C_Start
;;;232    	OLED_I2C_SendByte(0x78); // 发送OLED的I2C从机地址
00000a  2078              MOVS     r0,#0x78
00000c  f7fffffe          BL       OLED_I2C_SendByte
;;;233    	OLED_I2C_SendByte(0x40); // 控制字节，给0x40，表示即将写数据
000010  2040              MOVS     r0,#0x40
000012  f7fffffe          BL       OLED_I2C_SendByte
;;;234    	/*循环Count次，进行连续的数据写入*/
;;;235    	for (i = 0; i < Count; i++)
000016  2400              MOVS     r4,#0
000018  e004              B        |L36.36|
                  |L36.26|
;;;236    	{
;;;237    		OLED_I2C_SendByte(Data[i]); // 依次发送Data的每一个数据
00001a  5d28              LDRB     r0,[r5,r4]
00001c  f7fffffe          BL       OLED_I2C_SendByte
000020  1c60              ADDS     r0,r4,#1              ;235
000022  b2c4              UXTB     r4,r0                 ;235
                  |L36.36|
000024  42b4              CMP      r4,r6                 ;235
000026  dbf8              BLT      |L36.26|
;;;238    	}
;;;239    	OLED_I2C_Stop(); // I2C终止
000028  f7fffffe          BL       OLED_I2C_Stop
;;;240    }
00002c  bd70              POP      {r4-r6,pc}
;;;241    
                          ENDP


                          AREA ||i.OLED_pnpoly||, CODE, READONLY, ALIGN=1

                  OLED_pnpoly PROC
;;;348     */
;;;349    uint8_t OLED_pnpoly(uint8_t nvert, int16_t *vertx, int16_t *verty, int16_t testx, int16_t testy)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;350    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  461f              MOV      r7,r3
00000a  9e07              LDR      r6,[sp,#0x1c]
;;;351    	int16_t i, j, c = 0;
00000c  f04f0c00          MOV      r12,#0
;;;352    
;;;353    	/*此算法由W. Randolph Franklin提出*/
;;;354    	/*参考链接：https://wrfranklin.org/Research/Short_Notes/pnpoly.html*/
;;;355    	for (i = 0, j = nvert - 1; i < nvert; j = i++)
000010  2100              MOVS     r1,#0
000012  1e6b              SUBS     r3,r5,#1
000014  e034              B        |L37.128|
                  |L37.22|
;;;356    	{
;;;357    		if (((verty[i] > testy) != (verty[j] > testy)) &&
000016  f9320011          LDRSH    r0,[r2,r1,LSL #1]
00001a  42b0              CMP      r0,r6
00001c  dd01              BLE      |L37.34|
00001e  2001              MOVS     r0,#1
000020  e000              B        |L37.36|
                  |L37.34|
000022  2000              MOVS     r0,#0
                  |L37.36|
000024  f9328013          LDRSH    r8,[r2,r3,LSL #1]
000028  45b0              CMP      r8,r6
00002a  dd02              BLE      |L37.50|
00002c  f04f0801          MOV      r8,#1
000030  e001              B        |L37.54|
                  |L37.50|
000032  f04f0800          MOV      r8,#0
                  |L37.54|
000036  4540              CMP      r0,r8
000038  d01f              BEQ      |L37.122|
;;;358    			(testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))
00003a  f9340013          LDRSH    r0,[r4,r3,LSL #1]
00003e  f9348011          LDRSH    r8,[r4,r1,LSL #1]
000042  eba00008          SUB      r0,r0,r8
000046  f9328011          LDRSH    r8,[r2,r1,LSL #1]
00004a  eba60808          SUB      r8,r6,r8
00004e  fb00f008          MUL      r0,r0,r8
000052  f9328013          LDRSH    r8,[r2,r3,LSL #1]
000056  f9329011          LDRSH    r9,[r2,r1,LSL #1]
00005a  eba80809          SUB      r8,r8,r9
00005e  fb90f0f8          SDIV     r0,r0,r8
000062  f9348011          LDRSH    r8,[r4,r1,LSL #1]
000066  4440              ADD      r0,r0,r8
000068  42b8              CMP      r0,r7
00006a  dd06              BLE      |L37.122|
;;;359    		{
;;;360    			c = !c;
00006c  f1bc0f00          CMP      r12,#0
000070  d101              BNE      |L37.118|
000072  2001              MOVS     r0,#1
000074  e000              B        |L37.120|
                  |L37.118|
000076  2000              MOVS     r0,#0
                  |L37.120|
000078  4684              MOV      r12,r0
                  |L37.122|
00007a  460b              MOV      r3,r1                 ;355
00007c  1c48              ADDS     r0,r1,#1              ;355
00007e  b201              SXTH     r1,r0                 ;355
                  |L37.128|
000080  42a9              CMP      r1,r5                 ;355
000082  dbc8              BLT      |L37.22|
;;;361    		}
;;;362    	}
;;;363    	return c;
000084  f00c00ff          AND      r0,r12,#0xff
;;;364    }
000088  e8bd83f0          POP      {r4-r9,pc}
;;;365    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  OLED_DisplayBuf
                          %        1024
