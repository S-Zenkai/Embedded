; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\stm32f10x_rtc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\output\stm32f10x_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Drivers\CMSIS -I..\Drivers\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\Drivers\BSP\SYS -I..\Drivers\BSP\SYSTICK -I..\Drivers\BSP\USART -I..\Middlewares\FreeRTOS\include -I..\Middlewares\FreeRTOS\portable\RVDS\ARM_CM3 -I..\Drivers\BSP\LED -I..\Drivers\BSP\OLED -I..\Drivers\BSP\TIM -I..\Drivers\BSP\PWM -I..\Drivers\BSP\SYSTICK -I..\Drivers\BSP\SYS -ID:\AppData\keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=540 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\output\stm32f10x_rtc.crf ..\Drivers\STM32F10x_StdPeriph_Driver\src\stm32f10x_rtc.c]
                          THUMB

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;284      */
;;;285    void RTC_ClearFlag(uint16_t RTC_FLAG)
000000  4902              LDR      r1,|L1.12|
;;;286    {
;;;287      /* Check the parameters */
;;;288      assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
;;;289        
;;;290      /* Clear the corresponding RTC flag */
;;;291      RTC->CRL &= (uint16_t)~RTC_FLAG;
000002  8809              LDRH     r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L1.12|
000008  8011              STRH     r1,[r2,#0]
;;;292    }
00000a  4770              BX       lr
;;;293    
                          ENDP

                  |L1.12|
                          DCD      0x40002804

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;329      */
;;;330    void RTC_ClearITPendingBit(uint16_t RTC_IT)
000000  4902              LDR      r1,|L2.12|
;;;331    {
;;;332      /* Check the parameters */
;;;333      assert_param(IS_RTC_IT(RTC_IT));  
;;;334      
;;;335      /* Clear the corresponding RTC pending bit */
;;;336      RTC->CRL &= (uint16_t)~RTC_IT;
000002  8809              LDRH     r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L2.12|
000008  8011              STRH     r1,[r2,#0]
;;;337    }
00000a  4770              BX       lr
;;;338    
                          ENDP

                  |L2.12|
                          DCD      0x40002804

                          AREA ||i.RTC_EnterConfigMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterConfigMode PROC
;;;109      */
;;;110    void RTC_EnterConfigMode(void)
000000  4803              LDR      r0,|L3.16|
;;;111    {
;;;112      /* Set the CNF flag to enter in the Configuration Mode */
;;;113      RTC->CRL |= RTC_CRL_CNF;
000002  8800              LDRH     r0,[r0,#0]
000004  f0400010          ORR      r0,r0,#0x10
000008  4901              LDR      r1,|L3.16|
00000a  8008              STRH     r0,[r1,#0]
;;;114    }
00000c  4770              BX       lr
;;;115    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40002804

                          AREA ||i.RTC_ExitConfigMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitConfigMode PROC
;;;120      */
;;;121    void RTC_ExitConfigMode(void)
000000  4803              LDR      r0,|L4.16|
;;;122    {
;;;123      /* Reset the CNF flag to exit from the Configuration Mode */
;;;124      RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF); 
000002  8800              LDRH     r0,[r0,#0]
000004  f64f71ef          MOV      r1,#0xffef
000008  4008              ANDS     r0,r0,r1
00000a  4901              LDR      r1,|L4.16|
00000c  8008              STRH     r0,[r1,#0]
;;;125    }
00000e  4770              BX       lr
;;;126    
                          ENDP

                  |L4.16|
                          DCD      0x40002804

                          AREA ||i.RTC_GetCounter||, CODE, READONLY, ALIGN=2

                  RTC_GetCounter PROC
;;;131      */
;;;132    uint32_t RTC_GetCounter(void)
000000  2100              MOVS     r1,#0
;;;133    {
;;;134      uint16_t high1 = 0, high2 = 0, low = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;135    
;;;136      high1 = RTC->CNTH;
000006  4808              LDR      r0,|L5.40|
000008  8801              LDRH     r1,[r0,#0]
;;;137      low   = RTC->CNTL;
00000a  1d00              ADDS     r0,r0,#4
00000c  8803              LDRH     r3,[r0,#0]
;;;138      high2 = RTC->CNTH;
00000e  1f00              SUBS     r0,r0,#4
000010  8802              LDRH     r2,[r0,#0]
;;;139    
;;;140      if (high1 != high2)
000012  4291              CMP      r1,r2
000014  d004              BEQ      |L5.32|
;;;141      { /* In this case the counter roll over during reading of CNTL and CNTH registers, 
;;;142           read again CNTL register then return the counter value */
;;;143        return (((uint32_t) high2 << 16 ) | RTC->CNTL);
000016  1d00              ADDS     r0,r0,#4
000018  8800              LDRH     r0,[r0,#0]
00001a  ea404002          ORR      r0,r0,r2,LSL #16
                  |L5.30|
;;;144      }
;;;145      else
;;;146      { /* No counter roll over during reading of CNTL and CNTH registers, counter 
;;;147           value is equal to first value of CNTL and CNTH */
;;;148        return (((uint32_t) high1 << 16 ) | low);
;;;149      }
;;;150    }
00001e  4770              BX       lr
                  |L5.32|
000020  ea434001          ORR      r0,r3,r1,LSL #16      ;148
000024  e7fb              B        |L5.30|
;;;151    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x40002818

                          AREA ||i.RTC_GetDivider||, CODE, READONLY, ALIGN=2

                  RTC_GetDivider PROC
;;;204      */
;;;205    uint32_t RTC_GetDivider(void)
000000  2000              MOVS     r0,#0
;;;206    {
;;;207      uint32_t tmp = 0x00;
;;;208      tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;
000002  4904              LDR      r1,|L6.20|
000004  8809              LDRH     r1,[r1,#0]
000006  0709              LSLS     r1,r1,#28
000008  0b08              LSRS     r0,r1,#12
;;;209      tmp |= RTC->DIVL;
00000a  4902              LDR      r1,|L6.20|
00000c  1d09              ADDS     r1,r1,#4
00000e  8809              LDRH     r1,[r1,#0]
000010  4308              ORRS     r0,r0,r1
;;;210      return tmp;
;;;211    }
000012  4770              BX       lr
;;;212    
                          ENDP

                  |L6.20|
                          DCD      0x40002810

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;255      */
;;;256    FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG)
000000  4601              MOV      r1,r0
;;;257    {
;;;258      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;259      
;;;260      /* Check the parameters */
;;;261      assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
;;;262      
;;;263      if ((RTC->CRL & RTC_FLAG) != (uint16_t)RESET)
000004  4a03              LDR      r2,|L7.20|
000006  8812              LDRH     r2,[r2,#0]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L7.16|
;;;264      {
;;;265        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L7.18|
                  |L7.16|
;;;266      }
;;;267      else
;;;268      {
;;;269        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;270      }
;;;271      return bitstatus;
;;;272    }
000012  4770              BX       lr
;;;273    
                          ENDP

                  |L7.20|
                          DCD      0x40002804

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;302      */
;;;303    ITStatus RTC_GetITStatus(uint16_t RTC_IT)
000000  4601              MOV      r1,r0
;;;304    {
;;;305      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;306      /* Check the parameters */
;;;307      assert_param(IS_RTC_GET_IT(RTC_IT)); 
;;;308      
;;;309      bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
000004  4a06              LDR      r2,|L8.32|
000006  8812              LDRH     r2,[r2,#0]
000008  400a              ANDS     r2,r2,r1
00000a  b2d0              UXTB     r0,r2
;;;310      if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
00000c  4a04              LDR      r2,|L8.32|
00000e  1f12              SUBS     r2,r2,#4
000010  8812              LDRH     r2,[r2,#0]
000012  400a              ANDS     r2,r2,r1
000014  b112              CBZ      r2,|L8.28|
000016  b108              CBZ      r0,|L8.28|
;;;311      {
;;;312        bitstatus = SET;
000018  2001              MOVS     r0,#1
00001a  e000              B        |L8.30|
                  |L8.28|
;;;313      }
;;;314      else
;;;315      {
;;;316        bitstatus = RESET;
00001c  2000              MOVS     r0,#0
                  |L8.30|
;;;317      }
;;;318      return bitstatus;
;;;319    }
00001e  4770              BX       lr
;;;320    
                          ENDP

                  |L8.32|
                          DCD      0x40002804

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;88       */
;;;89     void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L9.14|
;;;90     {
;;;91       /* Check the parameters */
;;;92       assert_param(IS_RTC_IT(RTC_IT));  
;;;93       assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;94       
;;;95       if (NewState != DISABLE)
;;;96       {
;;;97         RTC->CRH |= RTC_IT;
000002  4a06              LDR      r2,|L9.28|
000004  8812              LDRH     r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L9.28|
00000a  801a              STRH     r2,[r3,#0]
00000c  e004              B        |L9.24|
                  |L9.14|
;;;98       }
;;;99       else
;;;100      {
;;;101        RTC->CRH &= (uint16_t)~RTC_IT;
00000e  4a03              LDR      r2,|L9.28|
000010  8812              LDRH     r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L9.28|
000016  801a              STRH     r2,[r3,#0]
                  |L9.24|
;;;102      }
;;;103    }
000018  4770              BX       lr
;;;104    
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x40002800

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;189      */
;;;190    void RTC_SetAlarm(uint32_t AlarmValue)
000000  b500              PUSH     {lr}
;;;191    {  
000002  4602              MOV      r2,r0
;;;192      RTC_EnterConfigMode();
000004  f7fffffe          BL       RTC_EnterConfigMode
;;;193      /* Set the ALARM MSB word */
;;;194      RTC->ALRH = AlarmValue >> 16;
000008  0c10              LSRS     r0,r2,#16
00000a  4903              LDR      r1,|L10.24|
00000c  8008              STRH     r0,[r1,#0]
;;;195      /* Set the ALARM LSB word */
;;;196      RTC->ALRL = (AlarmValue & RTC_LSB_MASK);
00000e  1d09              ADDS     r1,r1,#4
000010  800a              STRH     r2,[r1,#0]
;;;197      RTC_ExitConfigMode();
000012  f7fffffe          BL       RTC_ExitConfigMode
;;;198    }
000016  bd00              POP      {pc}
;;;199    
                          ENDP

                  |L10.24|
                          DCD      0x40002820

                          AREA ||i.RTC_SetCounter||, CODE, READONLY, ALIGN=2

                  RTC_SetCounter PROC
;;;156      */
;;;157    void RTC_SetCounter(uint32_t CounterValue)
000000  b500              PUSH     {lr}
;;;158    { 
000002  4602              MOV      r2,r0
;;;159      RTC_EnterConfigMode();
000004  f7fffffe          BL       RTC_EnterConfigMode
;;;160      /* Set RTC COUNTER MSB word */
;;;161      RTC->CNTH = CounterValue >> 16;
000008  0c10              LSRS     r0,r2,#16
00000a  4903              LDR      r1,|L11.24|
00000c  8008              STRH     r0,[r1,#0]
;;;162      /* Set RTC COUNTER LSB word */
;;;163      RTC->CNTL = (CounterValue & RTC_LSB_MASK);
00000e  1d09              ADDS     r1,r1,#4
000010  800a              STRH     r2,[r1,#0]
;;;164      RTC_ExitConfigMode();
000012  f7fffffe          BL       RTC_ExitConfigMode
;;;165    }
000016  bd00              POP      {pc}
;;;166    
                          ENDP

                  |L11.24|
                          DCD      0x40002818

                          AREA ||i.RTC_SetPrescaler||, CODE, READONLY, ALIGN=2

                  RTC_SetPrescaler PROC
;;;171      */
;;;172    void RTC_SetPrescaler(uint32_t PrescalerValue)
000000  b500              PUSH     {lr}
;;;173    {
000002  4602              MOV      r2,r0
;;;174      /* Check the parameters */
;;;175      assert_param(IS_RTC_PRESCALER(PrescalerValue));
;;;176      
;;;177      RTC_EnterConfigMode();
000004  f7fffffe          BL       RTC_EnterConfigMode
;;;178      /* Set RTC PRESCALER MSB word */
;;;179      RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
000008  f3c24003          UBFX     r0,r2,#16,#4
00000c  4903              LDR      r1,|L12.28|
00000e  8008              STRH     r0,[r1,#0]
;;;180      /* Set RTC PRESCALER LSB word */
;;;181      RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
000010  1d09              ADDS     r1,r1,#4
000012  800a              STRH     r2,[r1,#0]
;;;182      RTC_ExitConfigMode();
000014  f7fffffe          BL       RTC_ExitConfigMode
;;;183    }
000018  bd00              POP      {pc}
;;;184    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x40002808

                          AREA ||i.RTC_WaitForLastTask||, CODE, READONLY, ALIGN=2

                  RTC_WaitForLastTask PROC
;;;218      */
;;;219    void RTC_WaitForLastTask(void)
000000  bf00              NOP      
                  |L13.2|
;;;220    {
;;;221      /* Loop until RTOFF flag is set */
;;;222      while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
000002  4803              LDR      r0,|L13.16|
000004  8800              LDRH     r0,[r0,#0]
000006  f0000020          AND      r0,r0,#0x20
00000a  2800              CMP      r0,#0
00000c  d0f9              BEQ      |L13.2|
;;;223      {
;;;224      }
;;;225    }
00000e  4770              BX       lr
;;;226    
                          ENDP

                  |L13.16|
                          DCD      0x40002804

                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;234      */
;;;235    void RTC_WaitForSynchro(void)
000000  4807              LDR      r0,|L14.32|
;;;236    {
;;;237      /* Clear RSF flag */
;;;238      RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
000002  8800              LDRH     r0,[r0,#0]
000004  f64f71f7          MOV      r1,#0xfff7
000008  4008              ANDS     r0,r0,r1
00000a  4905              LDR      r1,|L14.32|
00000c  8008              STRH     r0,[r1,#0]
;;;239      /* Loop until RSF flag is set */
;;;240      while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
00000e  bf00              NOP      
                  |L14.16|
000010  4803              LDR      r0,|L14.32|
000012  8800              LDRH     r0,[r0,#0]
000014  f0000008          AND      r0,r0,#8
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L14.16|
;;;241      {
;;;242      }
;;;243    }
00001c  4770              BX       lr
;;;244    
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      0x40002804
