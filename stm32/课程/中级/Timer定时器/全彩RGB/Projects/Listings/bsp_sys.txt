; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\bsp_sys.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\output\bsp_sys.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Drivers\CMSIS -I..\Drivers\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\Drivers\BSP\SYS -I..\Drivers\BSP\SYSTICK -I..\Drivers\BSP\USART -I..\Middlewares\FreeRTOS\include -I..\Middlewares\FreeRTOS\portable\RVDS\ARM_CM3 -I..\Drivers\BSP\LED -I..\Drivers\BSP\OLED -I..\Drivers\BSP\TIM -I..\Drivers\BSP\PWM -I..\Drivers\BSP\SYSTICK -I..\Drivers\BSP\SYS -ID:\AppData\keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=540 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\output\bsp_sys.crf ..\Drivers\BSP\SYS\bsp_sys.c]
                          THUMB

                          AREA ||i.HSE_SetSysClock||, CODE, READONLY, ALIGN=1

                  HSE_SetSysClock PROC
;;;8      	*/
;;;9      void HSE_SetSysClock(uint32_t pllmul)
000000  b51c              PUSH     {r2-r4,lr}
;;;10     {
000002  4604              MOV      r4,r0
;;;11     	__IO uint32_t StartUpCounter = 0, HSEStartUpStatus = 0;
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
000008  9000              STR      r0,[sp,#0]
;;;12     	//把RCC外设初始化成默认复位状态
;;;13     	RCC_DeInit();
00000a  f7fffffe          BL       RCC_DeInit
;;;14     	//使能HSE
;;;15     	RCC_HSEConfig(RCC_HSE_ON);
00000e  f44f3080          MOV      r0,#0x10000
000012  f7fffffe          BL       RCC_HSEConfig
;;;16     	//等待HSE启动
;;;17     	HSEStartUpStatus=RCC_WaitForHSEStartUp();
000016  f7fffffe          BL       RCC_WaitForHSEStartUp
00001a  9000              STR      r0,[sp,#0]
;;;18     	//HSE正常启动
;;;19     	if(HSEStartUpStatus)
00001c  9800              LDR      r0,[sp,#0]
00001e  b328              CBZ      r0,|L1.108|
;;;20     	{
;;;21     		 // 使能FLASH 预存取缓冲区
;;;22         FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000020  2010              MOVS     r0,#0x10
000022  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;23     
;;;24         // SYSCLK周期与闪存访问时间的比例设置，这里统一设置成2
;;;25     		// 设置成2的时候，SYSCLK低于48M也可以工作，如果设置成0或者1的时候，
;;;26     		// 如果配置的SYSCLK超出了范围的话，则会进入硬件错误，程序就死了
;;;27     		// 0：0 < SYSCLK <= 24M
;;;28     		// 1：24< SYSCLK <= 48M
;;;29     		// 2：48< SYSCLK <= 72M
;;;30         FLASH_SetLatency(FLASH_Latency_2);
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       FLASH_SetLatency
;;;31     		//HCLK = SYSCLK
;;;32     		//PCLK1=HCLK/2
;;;33     		//PCLK2=HCLC
;;;34     		RCC_HCLKConfig(RCC_SYSCLK_Div1);
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       RCC_HCLKConfig
;;;35     		RCC_PCLK1Config(RCC_HCLK_Div2);
000032  f44f6080          MOV      r0,#0x400
000036  f7fffffe          BL       RCC_PCLK1Config
;;;36     		RCC_PCLK2Config(RCC_HCLK_Div1);
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       RCC_PCLK2Config
;;;37     		//配置PLL时钟源、倍频因子
;;;38     		//SYSCLK=PLLCLK*pllmul
;;;39     		RCC_PLLConfig(RCC_PLLSource_HSE_Div1, pllmul);
000040  4621              MOV      r1,r4
000042  f44f3080          MOV      r0,#0x10000
000046  f7fffffe          BL       RCC_PLLConfig
;;;40     		//使能PLL
;;;41     		RCC_PLLCmd(ENABLE);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       RCC_PLLCmd
;;;42     		/* Wait till PLL is ready */
;;;43         while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000050  bf00              NOP      
                  |L1.82|
000052  2039              MOVS     r0,#0x39
000054  f7fffffe          BL       RCC_GetFlagStatus
000058  2800              CMP      r0,#0
00005a  d0fa              BEQ      |L1.82|
;;;44         {
;;;45         }
;;;46     		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00005c  2002              MOVS     r0,#2
00005e  f7fffffe          BL       RCC_SYSCLKConfig
;;;47     		// 读取时钟切换状态位，确保PLLCLK被选为系统时钟
;;;48         while (RCC_GetSYSCLKSource() != 0x08)
000062  bf00              NOP      
                  |L1.100|
000064  f7fffffe          BL       RCC_GetSYSCLKSource
000068  2808              CMP      r0,#8
00006a  d1fb              BNE      |L1.100|
                  |L1.108|
;;;49         {
;;;50         }
;;;51     	}
;;;52     	else
;;;53     	{
;;;54     		/* If HSE fails to start-up, the application will have wrong clock 
;;;55              configuration. User can add here some code to deal with this error */
;;;56     	}
;;;57     }
00006c  bd1c              POP      {r2-r4,pc}
;;;58     
                          ENDP


                          AREA ||i.sys_intx_disable||, CODE, READONLY, ALIGN=1

                  sys_intx_disable PROC
;;;90      */
;;;91     void sys_intx_disable(void)
000000  b672              CPSID    i
;;;92     {
;;;93         __ASM volatile("cpsid i");
;;;94     }
000002  4770              BX       lr
;;;95     
                          ENDP


                          AREA ||i.sys_intx_enable||, CODE, READONLY, ALIGN=1

                  sys_intx_enable PROC
;;;100     */
;;;101    void sys_intx_enable(void)
000000  b662              CPSIE    i
;;;102    {
;;;103        __ASM volatile("cpsie i");
;;;104    }
000002  4770              BX       lr
;;;105    
                          ENDP


                          AREA ||i.sys_nvic_set_vector_table||, CODE, READONLY, ALIGN=2

                  sys_nvic_set_vector_table PROC
;;;69      */
;;;70     void sys_nvic_set_vector_table(uint32_t baseaddr, uint32_t offset)
000000  0a4a              LSRS     r2,r1,#9
;;;71     {
;;;72         /* 设置NVIC的向量表偏移寄存器,VTOR低9位保留,即[8:0]保留 */
;;;73         SCB->VTOR = baseaddr | (offset & (uint32_t)0xFFFFFE00);
000002  0252              LSLS     r2,r2,#9
000004  4302              ORRS     r2,r2,r0
000006  4b01              LDR      r3,|L4.12|
000008  601a              STR      r2,[r3,#0]
;;;74     }
00000a  4770              BX       lr
;;;75     
                          ENDP

                  |L4.12|
                          DCD      0xe000ed08

                          AREA ||i.sys_soft_reset||, CODE, READONLY, ALIGN=2

                  sys_soft_reset PROC
;;;137     */
;;;138    void sys_soft_reset(void)
000000  bf00              NOP      
000002  4807              LDR      r0,|L5.32|
000004  6800              LDR      r0,[r0,#0]
000006  f40060e0          AND      r0,r0,#0x700
00000a  4906              LDR      r1,|L5.36|
00000c  4308              ORRS     r0,r0,r1
00000e  1d00              ADDS     r0,r0,#4
000010  4903              LDR      r1,|L5.32|
000012  6008              STR      r0,[r1,#0]
000014  f3bf8f4f          DSB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L5.28|
00001c  e7fe              B        |L5.28|
;;;139    {
;;;140        NVIC_SystemReset();
;;;141    }
;;;142    
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      0xe000ed0c
                  |L5.36|
                          DCD      0x05fa0000

                          AREA ||i.sys_wfi_set||, CODE, READONLY, ALIGN=1

                  sys_wfi_set PROC
;;;80      */
;;;81     void sys_wfi_set(void)
000000  bf30              WFI      
;;;82     {
;;;83         __ASM volatile("wfi");
;;;84     }
000002  4770              BX       lr
;;;85     
                          ENDP

