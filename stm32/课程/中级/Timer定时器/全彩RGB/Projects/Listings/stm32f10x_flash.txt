; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\stm32f10x_flash.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\output\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Drivers\CMSIS -I..\Drivers\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\Drivers\BSP\SYS -I..\Drivers\BSP\SYSTICK -I..\Drivers\BSP\USART -I..\Middlewares\FreeRTOS\include -I..\Middlewares\FreeRTOS\portable\RVDS\ARM_CM3 -I..\Drivers\BSP\LED -I..\Drivers\BSP\OLED -I..\Drivers\BSP\TIM -I..\Drivers\BSP\PWM -I..\Drivers\BSP\SYSTICK -I..\Drivers\BSP\SYS -ID:\AppData\keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=540 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\output\stm32f10x_flash.crf ..\Drivers\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1436     */
;;;1437   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;1438   {
;;;1439   #ifdef STM32F10X_XL
;;;1440     /* Check the parameters */
;;;1441     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1442   
;;;1443     if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1444     {
;;;1445       /* Clear the flags */
;;;1446       FLASH->SR2 = FLASH_FLAG;
;;;1447     }
;;;1448     else
;;;1449     {
;;;1450       /* Clear the flags */
;;;1451       FLASH->SR = FLASH_FLAG;
;;;1452     }  
;;;1453   
;;;1454   #else
;;;1455     /* Check the parameters */
;;;1456     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1457     
;;;1458     /* Clear the flags */
;;;1459     FLASH->SR = FLASH_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;1460   #endif /* STM32F10X_XL */
;;;1461   }
000004  4770              BX       lr
;;;1462   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;968      */
;;;969    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;970    {
000004  4604              MOV      r4,r0
;;;971      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
00000a  4637              MOV      r7,r6
00000c  46b0              MOV      r8,r6
00000e  46b1              MOV      r9,r6
;;;972      
;;;973      FLASH_Status status = FLASH_COMPLETE;
000010  2504              MOVS     r5,#4
;;;974      
;;;975      /* Check the parameters */
;;;976      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;977      
;;;978      FLASH_Pages = (uint32_t)(~FLASH_Pages);
000012  43e4              MVNS     r4,r4
;;;979      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000014  b2e6              UXTB     r6,r4
;;;980      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000016  f3c42707          UBFX     r7,r4,#8,#8
;;;981      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
00001a  f3c44807          UBFX     r8,r4,#16,#8
;;;982      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
00001e  ea4f6914          LSR      r9,r4,#24
;;;983      
;;;984      /* Wait for last operation to be completed */
;;;985      status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  02e8              LSLS     r0,r5,#11
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4605              MOV      r5,r0
;;;986      
;;;987      if(status == FLASH_COMPLETE)
00002a  2d04              CMP      r5,#4
00002c  d13f              BNE      |L2.174|
;;;988      {
;;;989        /* Authorizes the small information block programming */
;;;990        FLASH->OPTKEYR = FLASH_KEY1;
00002e  4821              LDR      r0,|L2.180|
000030  4921              LDR      r1,|L2.184|
000032  6088              STR      r0,[r1,#8]
;;;991        FLASH->OPTKEYR = FLASH_KEY2;
000034  4821              LDR      r0,|L2.188|
000036  6088              STR      r0,[r1,#8]
;;;992        FLASH->CR |= CR_OPTPG_Set;
000038  4608              MOV      r0,r1
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6108              STR      r0,[r1,#0x10]
;;;993        if(WRP0_Data != 0xFF)
000042  2eff              CMP      r6,#0xff
000044  d005              BEQ      |L2.82|
;;;994        {
;;;995          OB->WRP0 = WRP0_Data;
000046  481e              LDR      r0,|L2.192|
000048  8006              STRH     r6,[r0,#0]
;;;996          
;;;997          /* Wait for last operation to be completed */
;;;998          status = FLASH_WaitForLastOperation(ProgramTimeout);
00004a  02e8              LSLS     r0,r5,#11
00004c  f7fffffe          BL       FLASH_WaitForLastOperation
000050  4605              MOV      r5,r0
                  |L2.82|
;;;999        }
;;;1000       if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000052  2d04              CMP      r5,#4
000054  d108              BNE      |L2.104|
000056  2fff              CMP      r7,#0xff
000058  d006              BEQ      |L2.104|
;;;1001       {
;;;1002         OB->WRP1 = WRP1_Data;
00005a  4819              LDR      r0,|L2.192|
00005c  1c80              ADDS     r0,r0,#2
00005e  8007              STRH     r7,[r0,#0]
;;;1003         
;;;1004         /* Wait for last operation to be completed */
;;;1005         status = FLASH_WaitForLastOperation(ProgramTimeout);
000060  02e8              LSLS     r0,r5,#11
000062  f7fffffe          BL       FLASH_WaitForLastOperation
000066  4605              MOV      r5,r0
                  |L2.104|
;;;1006       }
;;;1007       if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000068  2d04              CMP      r5,#4
00006a  d10a              BNE      |L2.130|
00006c  f1b80fff          CMP      r8,#0xff
000070  d007              BEQ      |L2.130|
;;;1008       {
;;;1009         OB->WRP2 = WRP2_Data;
000072  4813              LDR      r0,|L2.192|
000074  1d00              ADDS     r0,r0,#4
000076  f8a08000          STRH     r8,[r0,#0]
;;;1010         
;;;1011         /* Wait for last operation to be completed */
;;;1012         status = FLASH_WaitForLastOperation(ProgramTimeout);
00007a  02e8              LSLS     r0,r5,#11
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
000080  4605              MOV      r5,r0
                  |L2.130|
;;;1013       }
;;;1014       
;;;1015       if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000082  2d04              CMP      r5,#4
000084  d10a              BNE      |L2.156|
000086  f1b90fff          CMP      r9,#0xff
00008a  d007              BEQ      |L2.156|
;;;1016       {
;;;1017         OB->WRP3 = WRP3_Data;
00008c  480c              LDR      r0,|L2.192|
00008e  1d80              ADDS     r0,r0,#6
000090  f8a09000          STRH     r9,[r0,#0]
;;;1018        
;;;1019         /* Wait for last operation to be completed */
;;;1020         status = FLASH_WaitForLastOperation(ProgramTimeout);
000094  02e8              LSLS     r0,r5,#11
000096  f7fffffe          BL       FLASH_WaitForLastOperation
00009a  4605              MOV      r5,r0
                  |L2.156|
;;;1021       }
;;;1022             
;;;1023       if(status != FLASH_TIMEOUT)
00009c  2d05              CMP      r5,#5
00009e  d006              BEQ      |L2.174|
;;;1024       {
;;;1025         /* if the program operation is completed, disable the OPTPG Bit */
;;;1026         FLASH->CR &= CR_OPTPG_Reset;
0000a0  4805              LDR      r0,|L2.184|
0000a2  6900              LDR      r0,[r0,#0x10]
0000a4  f64171ef          MOV      r1,#0x1fef
0000a8  4008              ANDS     r0,r0,r1
0000aa  4903              LDR      r1,|L2.184|
0000ac  6108              STR      r0,[r1,#0x10]
                  |L2.174|
;;;1027       }
;;;1028     } 
;;;1029     /* Return the write protection operation Status */
;;;1030     return status;       
0000ae  4628              MOV      r0,r5
;;;1031   }
0000b0  e8bd83f0          POP      {r4-r9,pc}
;;;1032   
                          ENDP

                  |L2.180|
                          DCD      0x45670123
                  |L2.184|
                          DCD      0x40022000
                  |L2.188|
                          DCD      0xcdef89ab
                  |L2.192|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_EraseAllBank1Pages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Pages PROC
;;;548      */
;;;549    FLASH_Status FLASH_EraseAllBank1Pages(void)
000000  b510              PUSH     {r4,lr}
;;;550    {
;;;551      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;552      /* Wait for last operation to be completed */
;;;553      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastBank1Operation
00000c  4604              MOV      r4,r0
;;;554      
;;;555      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d116              BNE      |L3.64|
;;;556      {
;;;557        /* if the previous operation is completed, proceed to erase all pages */
;;;558         FLASH->CR |= CR_MER_Set;
000012  480c              LDR      r0,|L3.68|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490a              LDR      r1,|L3.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;559         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;560        
;;;561        /* Wait for last operation to be completed */
;;;562        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastBank1Operation
000030  4604              MOV      r4,r0
;;;563        
;;;564        /* Disable the MER Bit */
;;;565        FLASH->CR &= CR_MER_Reset;
000032  4804              LDR      r0,|L3.68|
000034  6900              LDR      r0,[r0,#0x10]
000036  f64171fb          MOV      r1,#0x1ffb
00003a  4008              ANDS     r0,r0,r1
00003c  4901              LDR      r1,|L3.68|
00003e  6108              STR      r0,[r1,#0x10]
                  |L3.64|
;;;566      }    
;;;567      /* Return the Erase Status */
;;;568      return status;
000040  4620              MOV      r0,r4
;;;569    }
000042  bd10              POP      {r4,pc}
;;;570    
                          ENDP

                  |L3.68|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;485      */
;;;486    FLASH_Status FLASH_EraseAllPages(void)
000000  b510              PUSH     {r4,lr}
;;;487    {
;;;488      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;489    
;;;490    #ifdef STM32F10X_XL
;;;491      /* Wait for last operation to be completed */
;;;492      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;493      
;;;494      if(status == FLASH_COMPLETE)
;;;495      {
;;;496        /* if the previous operation is completed, proceed to erase all pages */
;;;497         FLASH->CR |= CR_MER_Set;
;;;498         FLASH->CR |= CR_STRT_Set;
;;;499        
;;;500        /* Wait for last operation to be completed */
;;;501        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;502        
;;;503        /* Disable the MER Bit */
;;;504        FLASH->CR &= CR_MER_Reset;
;;;505      }    
;;;506      if(status == FLASH_COMPLETE)
;;;507      {
;;;508        /* if the previous operation is completed, proceed to erase all pages */
;;;509         FLASH->CR2 |= CR_MER_Set;
;;;510         FLASH->CR2 |= CR_STRT_Set;
;;;511        
;;;512        /* Wait for last operation to be completed */
;;;513        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;514        
;;;515        /* Disable the MER Bit */
;;;516        FLASH->CR2 &= CR_MER_Reset;
;;;517      }
;;;518    #else
;;;519      /* Wait for last operation to be completed */
;;;520      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;521      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d116              BNE      |L4.64|
;;;522      {
;;;523        /* if the previous operation is completed, proceed to erase all pages */
;;;524         FLASH->CR |= CR_MER_Set;
000012  480c              LDR      r0,|L4.68|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490a              LDR      r1,|L4.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;525         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;526        
;;;527        /* Wait for last operation to be completed */
;;;528        status = FLASH_WaitForLastOperation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;529    
;;;530        /* Disable the MER Bit */
;;;531        FLASH->CR &= CR_MER_Reset;
000032  4804              LDR      r0,|L4.68|
000034  6900              LDR      r0,[r0,#0x10]
000036  f64171fb          MOV      r1,#0x1ffb
00003a  4008              ANDS     r0,r0,r1
00003c  4901              LDR      r1,|L4.68|
00003e  6108              STR      r0,[r1,#0x10]
                  |L4.64|
;;;532      }
;;;533    #endif /* STM32F10X_XL */
;;;534    
;;;535      /* Return the Erase Status */
;;;536      return status;
000040  4620              MOV      r0,r4
;;;537    }
000042  bd10              POP      {r4,pc}
;;;538    
                          ENDP

                  |L4.68|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;609      */
;;;610    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b530              PUSH     {r4,r5,lr}
;;;611    {
;;;612      uint16_t rdptmp = RDP_Key;
000002  25a5              MOVS     r5,#0xa5
;;;613    
;;;614      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;615    
;;;616      /* Get the actual read protection Option Byte value */ 
;;;617      if(FLASH_GetReadOutProtectionStatus() != RESET)
000006  f7fffffe          BL       FLASH_GetReadOutProtectionStatus
00000a  b100              CBZ      r0,|L5.14|
;;;618      {
;;;619        rdptmp = 0x00;  
00000c  2500              MOVS     r5,#0
                  |L5.14|
;;;620      }
;;;621    
;;;622      /* Wait for last operation to be completed */
;;;623      status = FLASH_WaitForLastOperation(EraseTimeout);
00000e  f44f2030          MOV      r0,#0xb0000
000012  f7fffffe          BL       FLASH_WaitForLastOperation
000016  4604              MOV      r4,r0
;;;624      if(status == FLASH_COMPLETE)
000018  2c04              CMP      r4,#4
00001a  d13a              BNE      |L5.146|
;;;625      {
;;;626        /* Authorize the small information block programming */
;;;627        FLASH->OPTKEYR = FLASH_KEY1;
00001c  481e              LDR      r0,|L5.152|
00001e  491f              LDR      r1,|L5.156|
000020  6088              STR      r0,[r1,#8]
;;;628        FLASH->OPTKEYR = FLASH_KEY2;
000022  481f              LDR      r0,|L5.160|
000024  6088              STR      r0,[r1,#8]
;;;629        
;;;630        /* if the previous operation is completed, proceed to erase the option bytes */
;;;631        FLASH->CR |= CR_OPTER_Set;
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  6108              STR      r0,[r1,#0x10]
;;;632        FLASH->CR |= CR_STRT_Set;
000030  4608              MOV      r0,r1
000032  6900              LDR      r0,[r0,#0x10]
000034  f0400040          ORR      r0,r0,#0x40
000038  6108              STR      r0,[r1,#0x10]
;;;633        /* Wait for last operation to be completed */
;;;634        status = FLASH_WaitForLastOperation(EraseTimeout);
00003a  f44f2030          MOV      r0,#0xb0000
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4604              MOV      r4,r0
;;;635        
;;;636        if(status == FLASH_COMPLETE)
000044  2c04              CMP      r4,#4
000046  d11b              BNE      |L5.128|
;;;637        {
;;;638          /* if the erase operation is completed, disable the OPTER Bit */
;;;639          FLASH->CR &= CR_OPTER_Reset;
000048  4814              LDR      r0,|L5.156|
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f64171df          MOV      r1,#0x1fdf
000050  4008              ANDS     r0,r0,r1
000052  4912              LDR      r1,|L5.156|
000054  6108              STR      r0,[r1,#0x10]
;;;640           
;;;641          /* Enable the Option Bytes Programming operation */
;;;642          FLASH->CR |= CR_OPTPG_Set;
000056  4608              MOV      r0,r1
000058  6900              LDR      r0,[r0,#0x10]
00005a  f0400010          ORR      r0,r0,#0x10
00005e  6108              STR      r0,[r1,#0x10]
;;;643          /* Restore the last read protection Option Byte value */
;;;644          OB->RDP = (uint16_t)rdptmp; 
000060  4810              LDR      r0,|L5.164|
000062  8005              STRH     r5,[r0,#0]
;;;645          /* Wait for last operation to be completed */
;;;646          status = FLASH_WaitForLastOperation(ProgramTimeout);
000064  02e0              LSLS     r0,r4,#11
000066  f7fffffe          BL       FLASH_WaitForLastOperation
00006a  4604              MOV      r4,r0
;;;647     
;;;648          if(status != FLASH_TIMEOUT)
00006c  2c05              CMP      r4,#5
00006e  d010              BEQ      |L5.146|
;;;649          {
;;;650            /* if the program operation is completed, disable the OPTPG Bit */
;;;651            FLASH->CR &= CR_OPTPG_Reset;
000070  480a              LDR      r0,|L5.156|
000072  6900              LDR      r0,[r0,#0x10]
000074  f64171ef          MOV      r1,#0x1fef
000078  4008              ANDS     r0,r0,r1
00007a  4908              LDR      r1,|L5.156|
00007c  6108              STR      r0,[r1,#0x10]
00007e  e008              B        |L5.146|
                  |L5.128|
;;;652          }
;;;653        }
;;;654        else
;;;655        {
;;;656          if (status != FLASH_TIMEOUT)
000080  2c05              CMP      r4,#5
000082  d006              BEQ      |L5.146|
;;;657          {
;;;658            /* Disable the OPTPG Bit */
;;;659            FLASH->CR &= CR_OPTPG_Reset;
000084  4805              LDR      r0,|L5.156|
000086  6900              LDR      r0,[r0,#0x10]
000088  f64171ef          MOV      r1,#0x1fef
00008c  4008              ANDS     r0,r0,r1
00008e  4903              LDR      r1,|L5.156|
000090  6108              STR      r0,[r1,#0x10]
                  |L5.146|
;;;660          }
;;;661        }  
;;;662      }
;;;663      /* Return the erase status */
;;;664      return status;
000092  4620              MOV      r0,r4
;;;665    }
000094  bd30              POP      {r4,r5,pc}
;;;666    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      0x45670123
                  |L5.156|
                          DCD      0x40022000
                  |L5.160|
                          DCD      0xcdef89ab
                  |L5.164|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;412      */
;;;413    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b530              PUSH     {r4,r5,lr}
;;;414    {
000002  4604              MOV      r4,r0
;;;415      FLASH_Status status = FLASH_COMPLETE;
000004  2504              MOVS     r5,#4
;;;416      /* Check the parameters */
;;;417      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;418    
;;;419    #ifdef STM32F10X_XL
;;;420      if(Page_Address < FLASH_BANK1_END_ADDRESS)  
;;;421      {
;;;422        /* Wait for last operation to be completed */
;;;423        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;424        if(status == FLASH_COMPLETE)
;;;425        { 
;;;426          /* if the previous operation is completed, proceed to erase the page */
;;;427          FLASH->CR|= CR_PER_Set;
;;;428          FLASH->AR = Page_Address; 
;;;429          FLASH->CR|= CR_STRT_Set;
;;;430        
;;;431          /* Wait for last operation to be completed */
;;;432          status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;433    
;;;434          /* Disable the PER Bit */
;;;435          FLASH->CR &= CR_PER_Reset;
;;;436        }
;;;437      }
;;;438      else
;;;439      {
;;;440        /* Wait for last operation to be completed */
;;;441        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;442        if(status == FLASH_COMPLETE)
;;;443        { 
;;;444          /* if the previous operation is completed, proceed to erase the page */
;;;445          FLASH->CR2|= CR_PER_Set;
;;;446          FLASH->AR2 = Page_Address; 
;;;447          FLASH->CR2|= CR_STRT_Set;
;;;448        
;;;449          /* Wait for last operation to be completed */
;;;450          status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;451          
;;;452          /* Disable the PER Bit */
;;;453          FLASH->CR2 &= CR_PER_Reset;
;;;454        }
;;;455      }
;;;456    #else
;;;457      /* Wait for last operation to be completed */
;;;458      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f44f2030          MOV      r0,#0xb0000
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4605              MOV      r5,r0
;;;459      
;;;460      if(status == FLASH_COMPLETE)
000010  2d04              CMP      r5,#4
000012  d117              BNE      |L6.68|
;;;461      { 
;;;462        /* if the previous operation is completed, proceed to erase the page */
;;;463        FLASH->CR|= CR_PER_Set;
000014  480c              LDR      r0,|L6.72|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400002          ORR      r0,r0,#2
00001c  490a              LDR      r1,|L6.72|
00001e  6108              STR      r0,[r1,#0x10]
;;;464        FLASH->AR = Page_Address; 
000020  4608              MOV      r0,r1
000022  6144              STR      r4,[r0,#0x14]
;;;465        FLASH->CR|= CR_STRT_Set;
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6108              STR      r0,[r1,#0x10]
;;;466        
;;;467        /* Wait for last operation to be completed */
;;;468        status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  f44f2030          MOV      r0,#0xb0000
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  4605              MOV      r5,r0
;;;469        
;;;470        /* Disable the PER Bit */
;;;471        FLASH->CR &= CR_PER_Reset;
000036  4804              LDR      r0,|L6.72|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171fd          MOV      r1,#0x1ffd
00003e  4008              ANDS     r0,r0,r1
000040  4901              LDR      r1,|L6.72|
000042  6108              STR      r0,[r1,#0x10]
                  |L6.68|
;;;472      }
;;;473    #endif /* STM32F10X_XL */
;;;474    
;;;475      /* Return the Erase Status */
;;;476      return status;
000044  4628              MOV      r0,r5
;;;477    }
000046  bd30              POP      {r4,r5,pc}
;;;478    
                          ENDP

                  |L6.72|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetBank1Status||, CODE, READONLY, ALIGN=2

                  FLASH_GetBank1Status PROC
;;;1508     */
;;;1509   FLASH_Status FLASH_GetBank1Status(void)
000000  2004              MOVS     r0,#4
;;;1510   {
;;;1511     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1512     
;;;1513     if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L7.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L7.16|
;;;1514     {
;;;1515       flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L7.46|
                  |L7.16|
;;;1516     }
;;;1517     else 
;;;1518     {  
;;;1519       if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
000010  4907              LDR      r1,|L7.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010104          AND      r1,r1,#4
000018  b109              CBZ      r1,|L7.30|
;;;1520       { 
;;;1521         flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L7.46|
                  |L7.30|
;;;1522       }
;;;1523       else 
;;;1524       {
;;;1525         if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L7.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010110          AND      r1,r1,#0x10
000026  b109              CBZ      r1,|L7.44|
;;;1526         {
;;;1527           flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L7.46|
                  |L7.44|
;;;1528         }
;;;1529         else
;;;1530         {
;;;1531           flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L7.46|
;;;1532         }
;;;1533       }
;;;1534     }
;;;1535     /* Return the Flash Status */
;;;1536     return flashstatus;
;;;1537   }
00002e  4770              BX       lr
;;;1538   
                          ENDP

                  |L7.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1350     */
;;;1351   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;1352   {
;;;1353     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1354   
;;;1355   #ifdef STM32F10X_XL
;;;1356     /* Check the parameters */
;;;1357     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1358     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;1359     {
;;;1360       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
;;;1361       {
;;;1362         bitstatus = SET;
;;;1363       }
;;;1364       else
;;;1365       {
;;;1366         bitstatus = RESET;
;;;1367       }
;;;1368     }
;;;1369     else
;;;1370     {
;;;1371       if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1372       {
;;;1373         if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
;;;1374         {
;;;1375           bitstatus = SET;
;;;1376         }
;;;1377         else
;;;1378         {
;;;1379           bitstatus = RESET;
;;;1380         }
;;;1381       }
;;;1382       else
;;;1383       {
;;;1384         if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
;;;1385         {
;;;1386           bitstatus = SET;
;;;1387         }
;;;1388         else
;;;1389         {
;;;1390           bitstatus = RESET;
;;;1391         }
;;;1392       }
;;;1393     }
;;;1394   #else
;;;1395     /* Check the parameters */
;;;1396     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1397     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
000004  2901              CMP      r1,#1
000006  d108              BNE      |L8.26|
;;;1398     {
;;;1399       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
000008  4a08              LDR      r2,|L8.44|
00000a  69d2              LDR      r2,[r2,#0x1c]
00000c  f0020201          AND      r2,r2,#1
000010  b10a              CBZ      r2,|L8.22|
;;;1400       {
;;;1401         bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e008              B        |L8.40|
                  |L8.22|
;;;1402       }
;;;1403       else
;;;1404       {
;;;1405         bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e006              B        |L8.40|
                  |L8.26|
;;;1406       }
;;;1407     }
;;;1408     else
;;;1409     {
;;;1410      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00001a  4a04              LDR      r2,|L8.44|
00001c  68d2              LDR      r2,[r2,#0xc]
00001e  400a              ANDS     r2,r2,r1
000020  b10a              CBZ      r2,|L8.38|
;;;1411       {
;;;1412         bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L8.40|
                  |L8.38|
;;;1413       }
;;;1414       else
;;;1415       {
;;;1416         bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L8.40|
;;;1417       }
;;;1418     }
;;;1419   #endif /* STM32F10X_XL */
;;;1420   
;;;1421     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1422     return bitstatus;
;;;1423   }
000028  4770              BX       lr
;;;1424   
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;1253     */
;;;1254   FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  2000              MOVS     r0,#0
;;;1255   {
;;;1256     FlagStatus bitstatus = RESET;
;;;1257     
;;;1258     if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L9.20|
000004  6809              LDR      r1,[r1,#0]
000006  f0010120          AND      r1,r1,#0x20
00000a  b109              CBZ      r1,|L9.16|
;;;1259     {
;;;1260       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
;;;1261     }
;;;1262     else
;;;1263     {
;;;1264       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;1265     }
;;;1266     /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;1267     return bitstatus; 
;;;1268   }
000012  4770              BX       lr
;;;1269   
                          ENDP

                  |L9.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;1233     */
;;;1234   FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  2000              MOVS     r0,#0
;;;1235   {
;;;1236     FlagStatus readoutstatus = RESET;
;;;1237     if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L10.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0010102          AND      r1,r1,#2
00000a  b109              CBZ      r1,|L10.16|
;;;1238     {
;;;1239       readoutstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L10.18|
                  |L10.16|
;;;1240     }
;;;1241     else
;;;1242     {
;;;1243       readoutstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;1244     }
;;;1245     return readoutstatus;
;;;1246   }
000012  4770              BX       lr
;;;1247   
                          ENDP

                  |L10.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1470     */
;;;1471   FLASH_Status FLASH_GetStatus(void)
000000  2004              MOVS     r0,#4
;;;1472   {
;;;1473     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1474     
;;;1475     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L11.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L11.16|
;;;1476     {
;;;1477       flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L11.46|
                  |L11.16|
;;;1478     }
;;;1479     else 
;;;1480     {  
;;;1481       if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
000010  4907              LDR      r1,|L11.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010104          AND      r1,r1,#4
000018  b109              CBZ      r1,|L11.30|
;;;1482       { 
;;;1483         flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L11.46|
                  |L11.30|
;;;1484       }
;;;1485       else 
;;;1486       {
;;;1487         if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L11.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010110          AND      r1,r1,#0x10
000026  b109              CBZ      r1,|L11.44|
;;;1488         {
;;;1489           flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L11.46|
                  |L11.44|
;;;1490         }
;;;1491         else
;;;1492         {
;;;1493           flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L11.46|
;;;1494         }
;;;1495       }
;;;1496     }
;;;1497     /* Return the Flash Status */
;;;1498     return flashstatus;
;;;1499   }
00002e  4770              BX       lr
;;;1500   
                          ENDP

                  |L11.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;1209     */
;;;1210   uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L12.8|
;;;1211   {
;;;1212     /* Return the User Option Byte */
;;;1213     return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;1214   }
000006  4770              BX       lr
;;;1215   
                          ENDP

                  |L12.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;1221     */
;;;1222   uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L13.8|
;;;1223   {
;;;1224     /* Return the Flash write protection Register value */
;;;1225     return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;1226   }
000004  4770              BX       lr
;;;1227   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;274      */
;;;275    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  4905              LDR      r1,|L14.24|
;;;276    {
;;;277      /* Check the parameters */
;;;278      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;279      
;;;280      /* Enable or disable the Half cycle access */
;;;281      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210108          BIC      r1,r1,#8
000008  4a03              LDR      r2,|L14.24|
00000a  6011              STR      r1,[r2,#0]
;;;282      FLASH->ACR |= FLASH_HalfCycleAccess;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;283    }
000014  4770              BX       lr
;;;284    
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1283     */
;;;1284   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L15.14|
;;;1285   {
;;;1286   #ifdef STM32F10X_XL
;;;1287     /* Check the parameters */
;;;1288     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1289     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1290   
;;;1291     if((FLASH_IT & 0x80000000) != 0x0)
;;;1292     {
;;;1293       if(NewState != DISABLE)
;;;1294       {
;;;1295         /* Enable the interrupt sources */
;;;1296         FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
;;;1297       }
;;;1298       else
;;;1299       {
;;;1300         /* Disable the interrupt sources */
;;;1301         FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
;;;1302       }
;;;1303     }
;;;1304     else
;;;1305     {
;;;1306       if(NewState != DISABLE)
;;;1307       {
;;;1308         /* Enable the interrupt sources */
;;;1309         FLASH->CR |= FLASH_IT;
;;;1310       }
;;;1311       else
;;;1312       {
;;;1313         /* Disable the interrupt sources */
;;;1314         FLASH->CR &= ~(uint32_t)FLASH_IT;
;;;1315       }
;;;1316     }
;;;1317   #else
;;;1318     /* Check the parameters */
;;;1319     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1320     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1321   
;;;1322     if(NewState != DISABLE)
;;;1323     {
;;;1324       /* Enable the interrupt sources */
;;;1325       FLASH->CR |= FLASH_IT;
000002  4a06              LDR      r2,|L15.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L15.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L15.24|
                  |L15.14|
;;;1326     }
;;;1327     else
;;;1328     {
;;;1329       /* Disable the interrupt sources */
;;;1330       FLASH->CR &= ~(uint32_t)FLASH_IT;
00000e  4a03              LDR      r2,|L15.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L15.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L15.24|
;;;1331     }
;;;1332   #endif /* STM32F10X_XL */
;;;1333   }
000018  4770              BX       lr
;;;1334   
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;365      */
;;;366    void FLASH_Lock(void)
000000  4803              LDR      r0,|L16.16|
;;;367    {
;;;368      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;369      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L16.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;370    
;;;371    #ifdef STM32F10X_XL
;;;372      /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
;;;373      FLASH->CR2 |= CR_LOCK_Set;
;;;374    #endif /* STM32F10X_XL */
;;;375    }
00000c  4770              BX       lr
;;;376    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_LockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_LockBank1 PROC
;;;385      */
;;;386    void FLASH_LockBank1(void)
000000  4803              LDR      r0,|L17.16|
;;;387    {
;;;388      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;389      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L17.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;390    }
00000c  4770              BX       lr
;;;391    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;293      */
;;;294    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  4905              LDR      r1,|L18.24|
;;;295    {
;;;296      /* Check the parameters */
;;;297      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;298      
;;;299      /* Enable or disable the Prefetch Buffer */
;;;300      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210110          BIC      r1,r1,#0x10
000008  4a03              LDR      r2,|L18.24|
00000a  6011              STR      r1,[r2,#0]
;;;301      FLASH->ACR |= FLASH_PrefetchBuffer;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;302    }
000014  4770              BX       lr
;;;303    
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;851      */
;;;852    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;853    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;854      FLASH_Status status = FLASH_COMPLETE;
000006  2604              MOVS     r6,#4
;;;855      /* Check the parameters */
;;;856      assert_param(IS_FLASH_ADDRESS(Address));
;;;857    
;;;858    #ifdef STM32F10X_XL
;;;859      /* Wait for last operation to be completed */
;;;860      status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;861      
;;;862      if(Address < FLASH_BANK1_END_ADDRESS)
;;;863      {
;;;864        if(status == FLASH_COMPLETE)
;;;865        {
;;;866          /* if the previous operation is completed, proceed to program the new data */
;;;867          FLASH->CR |= CR_PG_Set;
;;;868      
;;;869          *(__IO uint16_t*)Address = Data;
;;;870          /* Wait for last operation to be completed */
;;;871          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;872    
;;;873          /* Disable the PG Bit */
;;;874          FLASH->CR &= CR_PG_Reset;
;;;875        }
;;;876      }
;;;877      else
;;;878      {
;;;879        if(status == FLASH_COMPLETE)
;;;880        {
;;;881          /* if the previous operation is completed, proceed to program the new data */
;;;882          FLASH->CR2 |= CR_PG_Set;
;;;883      
;;;884          *(__IO uint16_t*)Address = Data;
;;;885          /* Wait for last operation to be completed */
;;;886          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;887    
;;;888          /* Disable the PG Bit */
;;;889          FLASH->CR2 &= CR_PG_Reset;
;;;890        }
;;;891      }
;;;892    #else
;;;893      /* Wait for last operation to be completed */
;;;894      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  02f0              LSLS     r0,r6,#11
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4606              MOV      r6,r0
;;;895      
;;;896      if(status == FLASH_COMPLETE)
000010  2e04              CMP      r6,#4
000012  d111              BNE      |L19.56|
;;;897      {
;;;898        /* if the previous operation is completed, proceed to program the new data */
;;;899        FLASH->CR |= CR_PG_Set;
000014  4809              LDR      r0,|L19.60|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4907              LDR      r1,|L19.60|
00001e  6108              STR      r0,[r1,#0x10]
;;;900      
;;;901        *(__IO uint16_t*)Address = Data;
000020  8025              STRH     r5,[r4,#0]
;;;902        /* Wait for last operation to be completed */
;;;903        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  02f0              LSLS     r0,r6,#11
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4606              MOV      r6,r0
;;;904        
;;;905        /* Disable the PG Bit */
;;;906        FLASH->CR &= CR_PG_Reset;
00002a  4804              LDR      r0,|L19.60|
00002c  6900              LDR      r0,[r0,#0x10]
00002e  f64171fe          MOV      r1,#0x1ffe
000032  4008              ANDS     r0,r0,r1
000034  4901              LDR      r1,|L19.60|
000036  6108              STR      r0,[r1,#0x10]
                  |L19.56|
;;;907      } 
;;;908    #endif  /* STM32F10X_XL */
;;;909      
;;;910      /* Return the Program Status */
;;;911      return status;
000038  4630              MOV      r0,r6
;;;912    }
00003a  bd70              POP      {r4-r6,pc}
;;;913    
                          ENDP

                  |L19.60|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;922      */
;;;923    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;924    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;925      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;926      /* Check the parameters */
;;;927      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;928      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  02e0              LSLS     r0,r4,#11
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;929    
;;;930      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d117              BNE      |L20.68|
;;;931      {
;;;932        /* Authorize the small information block programming */
;;;933        FLASH->OPTKEYR = FLASH_KEY1;
000014  480c              LDR      r0,|L20.72|
000016  490d              LDR      r1,|L20.76|
000018  6088              STR      r0,[r1,#8]
;;;934        FLASH->OPTKEYR = FLASH_KEY2;
00001a  480d              LDR      r0,|L20.80|
00001c  6088              STR      r0,[r1,#8]
;;;935        /* Enables the Option Bytes Programming operation */
;;;936        FLASH->CR |= CR_OPTPG_Set; 
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400010          ORR      r0,r0,#0x10
000026  6108              STR      r0,[r1,#0x10]
;;;937        *(__IO uint16_t*)Address = Data;
000028  802e              STRH     r6,[r5,#0]
;;;938        
;;;939        /* Wait for last operation to be completed */
;;;940        status = FLASH_WaitForLastOperation(ProgramTimeout);
00002a  02e0              LSLS     r0,r4,#11
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;941        if(status != FLASH_TIMEOUT)
000032  2c05              CMP      r4,#5
000034  d006              BEQ      |L20.68|
;;;942        {
;;;943          /* if the program operation is completed, disable the OPTPG Bit */
;;;944          FLASH->CR &= CR_OPTPG_Reset;
000036  4805              LDR      r0,|L20.76|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171ef          MOV      r1,#0x1fef
00003e  4008              ANDS     r0,r0,r1
000040  4902              LDR      r1,|L20.76|
000042  6108              STR      r0,[r1,#0x10]
                  |L20.68|
;;;945        }
;;;946      }
;;;947      /* Return the Option Byte Data Program Status */
;;;948      return status;
000044  4620              MOV      r0,r4
;;;949    }
000046  bd70              POP      {r4-r6,pc}
;;;950    
                          ENDP

                  |L20.72|
                          DCD      0x45670123
                  |L20.76|
                          DCD      0x40022000
                  |L20.80|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;674      */
;;;675    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b578              PUSH     {r3-r6,lr}
;;;676    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;677      FLASH_Status status = FLASH_COMPLETE;
000006  2504              MOVS     r5,#4
;;;678      __IO uint32_t tmp = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;679    
;;;680      /* Check the parameters */
;;;681      assert_param(IS_FLASH_ADDRESS(Address));
;;;682    
;;;683    #ifdef STM32F10X_XL
;;;684      if(Address < FLASH_BANK1_END_ADDRESS - 2)
;;;685      { 
;;;686        /* Wait for last operation to be completed */
;;;687        status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
;;;688        if(status == FLASH_COMPLETE)
;;;689        {
;;;690          /* if the previous operation is completed, proceed to program the new first 
;;;691            half word */
;;;692          FLASH->CR |= CR_PG_Set;
;;;693      
;;;694          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;695          /* Wait for last operation to be completed */
;;;696          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;697     
;;;698          if(status == FLASH_COMPLETE)
;;;699          {
;;;700            /* if the previous operation is completed, proceed to program the new second 
;;;701            half word */
;;;702            tmp = Address + 2;
;;;703    
;;;704            *(__IO uint16_t*) tmp = Data >> 16;
;;;705        
;;;706            /* Wait for last operation to be completed */
;;;707            status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;708            
;;;709            /* Disable the PG Bit */
;;;710            FLASH->CR &= CR_PG_Reset;
;;;711          }
;;;712          else
;;;713          {
;;;714            /* Disable the PG Bit */
;;;715            FLASH->CR &= CR_PG_Reset;
;;;716           }
;;;717        }
;;;718      }
;;;719      else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
;;;720      {
;;;721        /* Wait for last operation to be completed */
;;;722        status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;723    
;;;724        if(status == FLASH_COMPLETE)
;;;725        {
;;;726          /* if the previous operation is completed, proceed to program the new first 
;;;727            half word */
;;;728          FLASH->CR |= CR_PG_Set;
;;;729      
;;;730          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;731    
;;;732          /* Wait for last operation to be completed */
;;;733          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;734          
;;;735    	  /* Disable the PG Bit */
;;;736          FLASH->CR &= CR_PG_Reset;
;;;737        }
;;;738        else
;;;739        {
;;;740          /* Disable the PG Bit */
;;;741          FLASH->CR &= CR_PG_Reset;
;;;742        }
;;;743    
;;;744        /* Wait for last operation to be completed */
;;;745        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;746    
;;;747        if(status == FLASH_COMPLETE)
;;;748        {
;;;749          /* if the previous operation is completed, proceed to program the new second 
;;;750          half word */
;;;751          FLASH->CR2 |= CR_PG_Set;
;;;752          tmp = Address + 2;
;;;753    
;;;754          *(__IO uint16_t*) tmp = Data >> 16;
;;;755        
;;;756          /* Wait for last operation to be completed */
;;;757          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;758            
;;;759          /* Disable the PG Bit */
;;;760          FLASH->CR2 &= CR_PG_Reset;
;;;761        }
;;;762        else
;;;763        {
;;;764          /* Disable the PG Bit */
;;;765          FLASH->CR2 &= CR_PG_Reset;
;;;766        }
;;;767      }
;;;768      else
;;;769      {
;;;770        /* Wait for last operation to be completed */
;;;771        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;772    
;;;773        if(status == FLASH_COMPLETE)
;;;774        {
;;;775          /* if the previous operation is completed, proceed to program the new first 
;;;776            half word */
;;;777          FLASH->CR2 |= CR_PG_Set;
;;;778      
;;;779          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;780          /* Wait for last operation to be completed */
;;;781          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;782     
;;;783          if(status == FLASH_COMPLETE)
;;;784          {
;;;785            /* if the previous operation is completed, proceed to program the new second 
;;;786            half word */
;;;787            tmp = Address + 2;
;;;788    
;;;789            *(__IO uint16_t*) tmp = Data >> 16;
;;;790        
;;;791            /* Wait for last operation to be completed */
;;;792            status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;793            
;;;794            /* Disable the PG Bit */
;;;795            FLASH->CR2 &= CR_PG_Reset;
;;;796          }
;;;797          else
;;;798          {
;;;799            /* Disable the PG Bit */
;;;800            FLASH->CR2 &= CR_PG_Reset;
;;;801          }
;;;802        }
;;;803      }
;;;804    #else
;;;805      /* Wait for last operation to be completed */
;;;806      status = FLASH_WaitForLastOperation(ProgramTimeout);
00000c  02e8              LSLS     r0,r5,#11
00000e  f7fffffe          BL       FLASH_WaitForLastOperation
000012  4605              MOV      r5,r0
;;;807      
;;;808      if(status == FLASH_COMPLETE)
000014  2d04              CMP      r5,#4
000016  d124              BNE      |L21.98|
;;;809      {
;;;810        /* if the previous operation is completed, proceed to program the new first 
;;;811        half word */
;;;812        FLASH->CR |= CR_PG_Set;
000018  4813              LDR      r0,|L21.104|
00001a  6900              LDR      r0,[r0,#0x10]
00001c  f0400001          ORR      r0,r0,#1
000020  4911              LDR      r1,|L21.104|
000022  6108              STR      r0,[r1,#0x10]
;;;813      
;;;814        *(__IO uint16_t*)Address = (uint16_t)Data;
000024  8034              STRH     r4,[r6,#0]
;;;815        /* Wait for last operation to be completed */
;;;816        status = FLASH_WaitForLastOperation(ProgramTimeout);
000026  02e8              LSLS     r0,r5,#11
000028  f7fffffe          BL       FLASH_WaitForLastOperation
00002c  4605              MOV      r5,r0
;;;817     
;;;818        if(status == FLASH_COMPLETE)
00002e  2d04              CMP      r5,#4
000030  d110              BNE      |L21.84|
;;;819        {
;;;820          /* if the previous operation is completed, proceed to program the new second 
;;;821          half word */
;;;822          tmp = Address + 2;
000032  1cb0              ADDS     r0,r6,#2
000034  9000              STR      r0,[sp,#0]
;;;823    
;;;824          *(__IO uint16_t*) tmp = Data >> 16;
000036  0c20              LSRS     r0,r4,#16
000038  9900              LDR      r1,[sp,#0]
00003a  8008              STRH     r0,[r1,#0]
;;;825        
;;;826          /* Wait for last operation to be completed */
;;;827          status = FLASH_WaitForLastOperation(ProgramTimeout);
00003c  02e8              LSLS     r0,r5,#11
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4605              MOV      r5,r0
;;;828            
;;;829          /* Disable the PG Bit */
;;;830          FLASH->CR &= CR_PG_Reset;
000044  4808              LDR      r0,|L21.104|
000046  6900              LDR      r0,[r0,#0x10]
000048  f64171fe          MOV      r1,#0x1ffe
00004c  4008              ANDS     r0,r0,r1
00004e  4906              LDR      r1,|L21.104|
000050  6108              STR      r0,[r1,#0x10]
000052  e006              B        |L21.98|
                  |L21.84|
;;;831        }
;;;832        else
;;;833        {
;;;834          /* Disable the PG Bit */
;;;835          FLASH->CR &= CR_PG_Reset;
000054  4804              LDR      r0,|L21.104|
000056  6900              LDR      r0,[r0,#0x10]
000058  f64171fe          MOV      r1,#0x1ffe
00005c  4008              ANDS     r0,r0,r1
00005e  4902              LDR      r1,|L21.104|
000060  6108              STR      r0,[r1,#0x10]
                  |L21.98|
;;;836        }
;;;837      }         
;;;838    #endif /* STM32F10X_XL */
;;;839       
;;;840      /* Return the Program Status */
;;;841      return status;
000062  4628              MOV      r0,r5
;;;842    }
000064  bd78              POP      {r3-r6,pc}
;;;843    
                          ENDP

000066  0000              DCW      0x0000
                  |L21.104|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;1042     */
;;;1043   FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1044   {
000002  4605              MOV      r5,r0
;;;1045     FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;1046     /* Check the parameters */
;;;1047     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1048     status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f44f2030          MOV      r0,#0xb0000
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;1049     if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d141              BNE      |L22.152|
;;;1050     {
;;;1051       /* Authorizes the small information block programming */
;;;1052       FLASH->OPTKEYR = FLASH_KEY1;
000014  4821              LDR      r0,|L22.156|
000016  4922              LDR      r1,|L22.160|
000018  6088              STR      r0,[r1,#8]
;;;1053       FLASH->OPTKEYR = FLASH_KEY2;
00001a  4822              LDR      r0,|L22.164|
00001c  6088              STR      r0,[r1,#8]
;;;1054       FLASH->CR |= CR_OPTER_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400020          ORR      r0,r0,#0x20
000026  6108              STR      r0,[r1,#0x10]
;;;1055       FLASH->CR |= CR_STRT_Set;
000028  4608              MOV      r0,r1
00002a  6900              LDR      r0,[r0,#0x10]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6108              STR      r0,[r1,#0x10]
;;;1056       /* Wait for last operation to be completed */
;;;1057       status = FLASH_WaitForLastOperation(EraseTimeout);
000032  f44f2030          MOV      r0,#0xb0000
000036  f7fffffe          BL       FLASH_WaitForLastOperation
00003a  4604              MOV      r4,r0
;;;1058       if(status == FLASH_COMPLETE)
00003c  2c04              CMP      r4,#4
00003e  d122              BNE      |L22.134|
;;;1059       {
;;;1060         /* if the erase operation is completed, disable the OPTER Bit */
;;;1061         FLASH->CR &= CR_OPTER_Reset;
000040  4817              LDR      r0,|L22.160|
000042  6900              LDR      r0,[r0,#0x10]
000044  f64171df          MOV      r1,#0x1fdf
000048  4008              ANDS     r0,r0,r1
00004a  4915              LDR      r1,|L22.160|
00004c  6108              STR      r0,[r1,#0x10]
;;;1062         /* Enable the Option Bytes Programming operation */
;;;1063         FLASH->CR |= CR_OPTPG_Set; 
00004e  4608              MOV      r0,r1
000050  6900              LDR      r0,[r0,#0x10]
000052  f0400010          ORR      r0,r0,#0x10
000056  6108              STR      r0,[r1,#0x10]
;;;1064         if(NewState != DISABLE)
000058  b11d              CBZ      r5,|L22.98|
;;;1065         {
;;;1066           OB->RDP = 0x00;
00005a  2000              MOVS     r0,#0
00005c  4912              LDR      r1,|L22.168|
00005e  8008              STRH     r0,[r1,#0]
000060  e002              B        |L22.104|
                  |L22.98|
;;;1067         }
;;;1068         else
;;;1069         {
;;;1070           OB->RDP = RDP_Key;  
000062  20a5              MOVS     r0,#0xa5
000064  4910              LDR      r1,|L22.168|
000066  8008              STRH     r0,[r1,#0]
                  |L22.104|
;;;1071         }
;;;1072         /* Wait for last operation to be completed */
;;;1073         status = FLASH_WaitForLastOperation(EraseTimeout); 
000068  f44f2030          MOV      r0,#0xb0000
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4604              MOV      r4,r0
;;;1074       
;;;1075         if(status != FLASH_TIMEOUT)
000072  2c05              CMP      r4,#5
000074  d010              BEQ      |L22.152|
;;;1076         {
;;;1077           /* if the program operation is completed, disable the OPTPG Bit */
;;;1078           FLASH->CR &= CR_OPTPG_Reset;
000076  480a              LDR      r0,|L22.160|
000078  6900              LDR      r0,[r0,#0x10]
00007a  f64171ef          MOV      r1,#0x1fef
00007e  4008              ANDS     r0,r0,r1
000080  4907              LDR      r1,|L22.160|
000082  6108              STR      r0,[r1,#0x10]
000084  e008              B        |L22.152|
                  |L22.134|
;;;1079         }
;;;1080       }
;;;1081       else 
;;;1082       {
;;;1083         if(status != FLASH_TIMEOUT)
000086  2c05              CMP      r4,#5
000088  d006              BEQ      |L22.152|
;;;1084         {
;;;1085           /* Disable the OPTER Bit */
;;;1086           FLASH->CR &= CR_OPTER_Reset;
00008a  4805              LDR      r0,|L22.160|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f64171df          MOV      r1,#0x1fdf
000092  4008              ANDS     r0,r0,r1
000094  4902              LDR      r1,|L22.160|
000096  6108              STR      r0,[r1,#0x10]
                  |L22.152|
;;;1087         }
;;;1088       }
;;;1089     }
;;;1090     /* Return the protection operation Status */
;;;1091     return status;       
000098  4620              MOV      r0,r4
;;;1092   }
00009a  bd30              POP      {r4,r5,pc}
;;;1093   
                          ENDP

                  |L22.156|
                          DCD      0x45670123
                  |L22.160|
                          DCD      0x40022000
                  |L22.164|
                          DCD      0xcdef89ab
                  |L22.168|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;247      */
;;;248    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4601              MOV      r1,r0
;;;249    {
;;;250      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;251      
;;;252      /* Check the parameters */
;;;253      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;254      
;;;255      /* Read the ACR register */
;;;256      tmpreg = FLASH->ACR;  
000004  4a03              LDR      r2,|L23.20|
000006  6810              LDR      r0,[r2,#0]
;;;257      
;;;258      /* Sets the Latency value */
;;;259      tmpreg &= ACR_LATENCY_Mask;
000008  f0000038          AND      r0,r0,#0x38
;;;260      tmpreg |= FLASH_Latency;
00000c  4308              ORRS     r0,r0,r1
;;;261      
;;;262      /* Write the ACR register */
;;;263      FLASH->ACR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;264    }
000010  4770              BX       lr
;;;265    
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;312      */
;;;313    void FLASH_Unlock(void)
000000  4802              LDR      r0,|L24.12|
;;;314    {
;;;315      /* Authorize the FPEC of Bank1 Access */
;;;316      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L24.16|
000004  6048              STR      r0,[r1,#4]
;;;317      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L24.20|
000008  6048              STR      r0,[r1,#4]
;;;318    
;;;319    #ifdef STM32F10X_XL
;;;320      /* Authorize the FPEC of Bank2 Access */
;;;321      FLASH->KEYR2 = FLASH_KEY1;
;;;322      FLASH->KEYR2 = FLASH_KEY2;
;;;323    #endif /* STM32F10X_XL */
;;;324    }
00000a  4770              BX       lr
;;;325    /**
                          ENDP

                  |L24.12|
                          DCD      0x45670123
                  |L24.16|
                          DCD      0x40022000
                  |L24.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UnlockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_UnlockBank1 PROC
;;;333      */
;;;334    void FLASH_UnlockBank1(void)
000000  4802              LDR      r0,|L25.12|
;;;335    {
;;;336      /* Authorize the FPEC of Bank1 Access */
;;;337      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L25.16|
000004  6048              STR      r0,[r1,#4]
;;;338      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L25.20|
000008  6048              STR      r0,[r1,#4]
;;;339    }
00000a  4770              BX       lr
;;;340    
                          ENDP

                  |L25.12|
                          DCD      0x45670123
                  |L25.16|
                          DCD      0x40022000
                  |L25.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;1111     */
;;;1112   FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1113   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1114     FLASH_Status status = FLASH_COMPLETE; 
000008  2404              MOVS     r4,#4
;;;1115   
;;;1116     /* Check the parameters */
;;;1117     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;1118     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;1119     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;1120   
;;;1121     /* Authorize the small information block programming */
;;;1122     FLASH->OPTKEYR = FLASH_KEY1;
00000a  4813              LDR      r0,|L26.88|
00000c  4913              LDR      r1,|L26.92|
00000e  6088              STR      r0,[r1,#8]
;;;1123     FLASH->OPTKEYR = FLASH_KEY2;
000010  4813              LDR      r0,|L26.96|
000012  6088              STR      r0,[r1,#8]
;;;1124     
;;;1125     /* Wait for last operation to be completed */
;;;1126     status = FLASH_WaitForLastOperation(ProgramTimeout);
000014  02e0              LSLS     r0,r4,#11
000016  f7fffffe          BL       FLASH_WaitForLastOperation
00001a  4604              MOV      r4,r0
;;;1127     
;;;1128     if(status == FLASH_COMPLETE)
00001c  2c04              CMP      r4,#4
00001e  d118              BNE      |L26.82|
;;;1129     {  
;;;1130       /* Enable the Option Bytes Programming operation */
;;;1131       FLASH->CR |= CR_OPTPG_Set; 
000020  480e              LDR      r0,|L26.92|
000022  6900              LDR      r0,[r0,#0x10]
000024  f0400010          ORR      r0,r0,#0x10
000028  490c              LDR      r1,|L26.92|
00002a  6108              STR      r0,[r1,#0x10]
;;;1132              
;;;1133       OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
00002c  f04700f8          ORR      r0,r7,#0xf8
000030  4330              ORRS     r0,r0,r6
000032  4328              ORRS     r0,r0,r5
000034  490b              LDR      r1,|L26.100|
000036  8008              STRH     r0,[r1,#0]
;;;1134     
;;;1135       /* Wait for last operation to be completed */
;;;1136       status = FLASH_WaitForLastOperation(ProgramTimeout);
000038  02e0              LSLS     r0,r4,#11
00003a  f7fffffe          BL       FLASH_WaitForLastOperation
00003e  4604              MOV      r4,r0
;;;1137       if(status != FLASH_TIMEOUT)
000040  2c05              CMP      r4,#5
000042  d006              BEQ      |L26.82|
;;;1138       {
;;;1139         /* if the program operation is completed, disable the OPTPG Bit */
;;;1140         FLASH->CR &= CR_OPTPG_Reset;
000044  4805              LDR      r0,|L26.92|
000046  6900              LDR      r0,[r0,#0x10]
000048  f64171ef          MOV      r1,#0x1fef
00004c  4008              ANDS     r0,r0,r1
00004e  4903              LDR      r1,|L26.92|
000050  6108              STR      r0,[r1,#0x10]
                  |L26.82|
;;;1141       }
;;;1142     }    
;;;1143     /* Return the Option Byte program Status */
;;;1144     return status;
000052  4620              MOV      r0,r4
;;;1145   }
000054  bdf0              POP      {r4-r7,pc}
;;;1146   
                          ENDP

000056  0000              DCW      0x0000
                  |L26.88|
                          DCD      0x45670123
                  |L26.92|
                          DCD      0x40022000
                  |L26.96|
                          DCD      0xcdef89ab
                  |L26.100|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastBank1Operation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastBank1Operation PROC
;;;1616     */
;;;1617   FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1618   { 
000002  4602              MOV      r2,r0
;;;1619     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1620      
;;;1621     /* Check for the Flash Status */
;;;1622     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1623     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1624     while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
00000c  e003              B        |L27.22|
                  |L27.14|
;;;1625     {
;;;1626       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1627       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L27.22|
000016  2b01              CMP      r3,#1                 ;1624
000018  d101              BNE      |L27.30|
00001a  2a00              CMP      r2,#0                 ;1624
00001c  d1f7              BNE      |L27.14|
                  |L27.30|
;;;1628     }
;;;1629     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L27.34|
;;;1630     {
;;;1631       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L27.34|
;;;1632     }
;;;1633     /* Return the operation status */
;;;1634     return status;
000022  4618              MOV      r0,r3
;;;1635   }
000024  bd00              POP      {pc}
;;;1636   
                          ENDP


                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1588     */
;;;1589   FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1590   { 
000002  4602              MOV      r2,r0
;;;1591     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1592      
;;;1593     /* Check for the Flash Status */
;;;1594     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1595     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1596     while((status == FLASH_BUSY) && (Timeout != 0x00))
00000c  e003              B        |L28.22|
                  |L28.14|
;;;1597     {
;;;1598       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1599       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L28.22|
000016  2b01              CMP      r3,#1                 ;1596
000018  d101              BNE      |L28.30|
00001a  2a00              CMP      r2,#0                 ;1596
00001c  d1f7              BNE      |L28.14|
                  |L28.30|
;;;1600     }
;;;1601     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L28.34|
;;;1602     {
;;;1603       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L28.34|
;;;1604     }
;;;1605     /* Return the operation status */
;;;1606     return status;
000022  4618              MOV      r0,r3
;;;1607   }
000024  bd00              POP      {pc}
;;;1608   
                          ENDP

